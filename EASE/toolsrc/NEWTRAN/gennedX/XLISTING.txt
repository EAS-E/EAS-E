Routine MAIN
'' in this project, this exists only so that easinit() will be generated
RETURN END
Function INITERRS SUCCESS SYSDIR N I
WRITE CONCAT.F(SYSDIR, "\\easeerrs.txt") AS "Opening ", T *, / USING 97
OPEN 1 FOR INPUT, NAME IS CONCAT.F(SYSDIR, "\\easeerrs.txt")
USE 1 FOR INPUT
IF ROPENERR.V NE 0
	WRITE AS "Open failed", / USING 97
	RETURN WITH 1
ENDIF
LET EOF.V = 1
READ N
READ AS /
RESERVE ERRMSGS AS N
FOR I = 1 TO N
 WHILE EOF.V NE 2
DO
	READ ERRMSGS(I) AS T RRECLEN.V, /
LOOP
CLOSE 1
RETURN WITH 0
END
Routine EASERR ERRNO TERM
CREATE AN ERRORREC
LET ERRNUM(ERRORREC) = ERRNO
LET INPROC(ERRORREC) = CURRPROC
LET LINENUM(ERRORREC) = CURRLINE
IF F.ERRORRECS EQ 0
	LET F.ERRORRECS = ERRORREC
ELSE
	LET S.ERRORRECS(L.ERRORRECS) = ERRORREC
ENDIF
LET L.ERRORRECS = ERRORREC
IF ERRNO GT 0
	LET ERRCOUNT(CURRPROC) = ERRCOUNT(CURRPROC) + 1
	WRITE AS "!!! Error " USING 98
ELSE
	LET ERRNO = - ERRNO
	WRITE AS "--- Warning " USING 98
ENDIF
WRITE ERRNO AS I 4 USING 98
IF TERM NE ""
	WRITE TERM AS " involving ", T *, S 2 USING 98
ENDIF
IF CURRPROC NE 0
WRITE LEXEME(PDICTREF(CURRPROC)), CURRLINE
	AS " in ", T *, " at line ", I 4, S 2 USING 98
ENDIF
WRITE ERRMSGS(ERRNO - 1000)	AS T *, / USING 98
RETURN END
Routine TRANSLATEPROCS ASCHEMA FILENAME APROC AUSE BODYTEXT PROCENT INIT
LET ASCHEMA = F.SCHEMAS
WHILE ASCHEMA NE 0
DO
  IF NOGEN(ASCHEMA) EQ 0
    LET FILENAME = CONCAT.F(GENNAME(ASCHEMA), ".cpp")
	LET FILENAME = CONCAT.F(GENDIR, FILENAME)
	WRITE FILENAME AS "Generating ", T *, / USING 97
 	OPEN 6 FOR OUTPUT, NAME IS FILENAME
	USE 6 FOR OUTPUT
	CALL GENPROCINCL(ASCHEMA)
	LET APROC = F.PROCS(ASCHEMA)
	WHILE APROC NE 0
	DO
		LET CURRPROC = APROC
		LET AUSE = FINDSPECUSE_F(PDICTREF(APROC), .USE.PROC)
		LET PROCENT = USEENTITY(AUSE)
		LET BODYTEXT = PROCBODY(PROCENT)
		IF BODYTEXT NE ""
			CALL PROCTITLE(APROC)
			CALL BUILDSOURCE(BODYTEXT)
		ELSE
			CALL CLEARSRCLINES 
			LET F.TOKENLIST = F.SCRIPTTOKENS(APROC)
			LET L.TOKENLIST = L.SCRIPTTOKENS(APROC)
		ENDIF
		LET CURRLOOPDEPTH = 0		'' reset these for scripting
		LET LBL = 0
		LET LV = 0
		CALL MAKELCLSFROMXML(APROC)
		CALL PARSE(APROC)
		IF LEXEME(PDICTREF(APROC)) EQ "MAIN"
			CALL GENINIT
		ENDIF
		IF ERRCOUNT(APROC) EQ 0
			CALL MAKELCLS(APROC)
			CALL GENPROC(APROC)
			CALL DESTROYLCLS(PROCENT)	'' don't keep them!
		ENDIF
		LET APROC = S.PROCS(APROC)
	LOOP
	CLOSE 6
  ENDIF
  LET ASCHEMA = S_SCHEMAS(ASCHEMA)
LOOP
LET ASCHEMA = F.SCHEMAS
WHILE ASCHEMA NE 0
DO							'' gen headers after procedures - when entity types get USE
  IF NOGEN(ASCHEMA) EQ 0
    LET FILENAME = CONCAT.F(GENNAME(ASCHEMA), ".h")
 	OPEN 6 FOR OUTPUT, NAME IS CONCAT.F(GENDIR, FILENAME)
	USE 6 FOR OUTPUT
	CALL GENHEADER(ASCHEMA)
	CLOSE 6
  ENDIF
  LET ASCHEMA = S_SCHEMAS(ASCHEMA)
LOOP
RETURN
Routine PROCTITLE APROC SAVW AUSE ATT
LET SAVW = WRITE.V
USE 98 FOR OUTPUT
IF RETURNATT(APROC) NE 0
	WRITE AS "Function "
ELSE
	WRITE AS "Routine "
ENDIF
WRITE LEXEME(PDICTREF(APROC)) AS T *
LET AUSE = FINDSPECUSE_F(PDICTREF(APROC), .USE.PROC)
LET ATT = F.ATTRDEFS(USEENTITY(AUSE))
WHILE ATT NE 0
DO
	WRITE ATTRNAME(ATT) AS S 1, T *
	LET ATT = S.ATTRDEFS(ATT)
LOOP
WRITE AS /
USE SAVW FOR OUTPUT
RETURN END
Routine LISTING ASCHEMA APROC
OPEN 6 FOR OUTPUT, NAME IS CONCAT.F(GENDIR, "proj.lst")
USE 6 FOR OUTPUT
LET ASCHEMA = F.SCHEMAS
WHILE ASCHEMA NE 0
DO
''  IF ISSYSDEF(ASCHEMA) EQ 0
	LET APROC = F.PROCS(ASCHEMA)
	WHILE APROC NE 0
	DO
''		CALL PRINTPROC(APROC)
		CALL PRINTSTARS(APROC)
		LET APROC = S.PROCS(APROC)
	LOOP
''  ENDIF
  LET ASCHEMA = S_SCHEMAS(ASCHEMA)
LOOP
WRITE TOTLINES AS " DONE: LINES = ", I 6, /
CLOSE 6
RETURN END
Routine PRINTPROC APROC ANODE ATOKEN ASTMT I
WRITE LEXEME(PDICTREF(APROC)) AS "Procedure ", T *, /
LET ASTMT = F.STMTS(APROC)
WHILE ASTMT NE 0
DO
	LET ATOKEN = F.TOKENS(ASTMT)
	LET I = SCRIPTDEPTH(ASTMT)
	IF I EQ 0
		WRITE AS B 4
		WHILE ATOKEN NE 0
		DO
			WRITE LEXEME(DICTREF(ATOKEN)) AS T *, S 1
			LET ATOKEN = S.TOKENLIST(ATOKEN)
		LOOP
		WRITE AS /
	ENDIF
	LET ASTMT = S.STMTS(ASTMT)
LOOP
WRITE AS /
RETURN
Routine PRINTSTARS APROC ANODE ATOKEN ASTMT I
WRITE LEXEME(PDICTREF(APROC)) AS /, "Procedure ", T *, /
LET ASTMT = F.STMTS(APROC)
WHILE ASTMT NE 0
DO
	LET ATOKEN = F.TOKENS(ASTMT)
	LET I = SCRIPTDEPTH(ASTMT)
	WHILE I GT 0
	DO
		WRITE "*" AS T 1
		LET I = I - 1
	LOOP
	WRITE AS B 4
	WHILE ATOKEN NE 0
	DO
		WRITE LEXEME(DICTREF(ATOKEN)) AS T *, S 1
		LET ATOKEN = S.TOKENLIST(ATOKEN)
	LOOP
	WRITE AS /
	LET ASTMT = S.STMTS(ASTMT)
LOOP
RETURN
Routine DESTROYLCLS PROCENT DREF AUSE DUSE LUSE ATT
LET ATT = F.ATTRDEFS(PROCENT)
WHILE ATT NE 0
DO
	LET DREF = FINDDICTENTRY_F(ATTRNAME(ATT))
	LET DUSE = FINDSPECUSE_F(DREF, .USE.LCL)
	LET AUSE = F.USAGE(DREF)
	WHILE AUSE NE 0
	DO
		IF AUSE = DUSE
			IF LUSE NE 0
				LET S.USAGE(LUSE) = S.USAGE(AUSE)
			ELSE
				LET F.USAGE(DREF) = S.USAGE(AUSE)
			ENDIF
			DESTROY DICTUSE CALLED DUSE
			LET AUSE = 0
		ELSE
			LET LUSE = AUSE
			LET AUSE = S.USAGE(AUSE)
		ENDIF
		
	LOOP
	LET ATT = S.ATTRDEFS(ATT)
LOOP
Routine MAKELCLS APROC PROCENT DREF AUSE ATT NEWATT ALCL
LET AUSE = FINDSPECUSE_F(PDICTREF(APROC), .USE.PROC)
LET PROCENT = USEENTITY(AUSE)
LET ATT = F.ATTRDEFS(PROCENT)
IF F.LCLDEFS(APROC) NE 0
	IF ATT NE 0						'' some possibly defined by XML - (deprecated)
		WHILE S.ATTRDEFS(ATT) NE 0
		DO
			LET ATT = S.ATTRDEFS(ATT)
		LOOP
	ENDIF
	LET ALCL = F.LCLDEFS(APROC)		'' definitions from source code / scripting
	WHILE ALCL NE 0
	DO
		CREATE AN ATTRDEF CALLED NEWATT
		IF ATT NE 0
			LET S.ATTRDEFS(ATT) = NEWATT
		ELSE
			LET F.ATTRDEFS(PROCENT) = NEWATT
		ENDIF
		LET ATT = NEWATT
		LET ATTRNAME(NEWATT) = LDEFNAME(ALCL)
		LET ATTRTYPE(NEWATT) = LDEFTYPE(ALCL)
		IF ATTRTYPE(NEWATT) EQ 0
			CALL EASERR(-1002, ATTRNAME(NEWATT))		'' undefined..
			LET ATTRTYPE(NEWATT) = E.BUILTINS(1)		'' ..make Integer
		ENDIF
		LET ISPARAM(NEWATT) = LPARAM(ALCL)
		LET ISYIELD(NEWATT) = LYLD(ALCL)
		LET SUBSCRIPTS(NEWATT) = LDEFDIM(ALCL)
		LET ISRETTYPE(NEWATT) = LRET(ALCL)
		IF LRET(ALCL) NE 0
			LET ISRETTYPE(NEWATT) = LRET(ALCL)
			LET RETURNATT(APROC) = NEWATT
		ENDIF
		LET DREF = FINDDICTENTRY.F(ATTRNAME(NEWATT))
		LET AUSE = MAKEUSE_F(DREF, .USE.LCL)
		LET USEENTITY(AUSE) = ATTRTYPE(NEWATT)
		LET USEMODE(AUSE) = FINDMODE.F(ATTRTYPE(NEWATT))
		LET USESUBS(AUSE) = SUBSCRIPTS(NEWATT)
		LET ALCL = S.LCLDEFS(ALCL)
	LOOP
ENDIF
RETURN END
Routine MAKELCLSFROMXML APROC PROCENT DREF AUSE ATT
LET AUSE = FINDSPECUSE_F(PDICTREF(APROC), .USE.PROC)
LET PROCENT = USEENTITY(AUSE)
LET ATT = F.ATTRDEFS(PROCENT)
WHILE ATT NE 0
DO
	LET DREF = FINDDICTENTRY.F(ATTRNAME(ATT))
	LET AUSE = MAKEUSE_F(DREF, .USE.LCL)
	IF ATTRTYPE(ATT) EQ 0
		CALL EASERR(-1002, ATTRNAME(ATT))		'' undefined
		LET ATTRTYPE(ATT) = E.BUILTINS(1)
	ENDIF
	LET USEENTITY(AUSE) = ATTRTYPE(ATT)
	LET USEMODE(AUSE) = FINDMODE.F(ATTRTYPE(ATT))
	LET USESUBS(AUSE) = SUBSCRIPTS(ATT)
	LET ATT = S.ATTRDEFS(ATT)
LOOP
RETURN END
Routine READSOURCE ALINE LASTLINE
OPEN 5 FOR INPUT, NAME IS "source.txt"
USE 5 FOR INPUT
LET EOF.V = 1
WHILE EOF.V NE 2
DO
	READ ALINE AS T RRECLEN.V
	CREATE A SRCLINE 
	IF F.SRCLINES EQ 0
		LET F.SRCLINES = SRCLINE
	ELSE
		LET S.SRCLINES(LASTLINE) = SRCLINE
	ENDIF
	LET LASTLINE = SRCLINE
	LET LTXT(SRCLINE) = ALINE
	READ AS /
LOOP
CLOSE 5
Routine LISTSYNTAX I ENTRY RULE
OPEN 6 FOR OUTPUT, NAME IS "listrules.txt"
USE 6 FOR OUTPUT
FOR I = 1 TO 128
DO
	WRITE I AS I 3
	IF F_DICT(I) NE 0
		LET ENTRY = F_DICT(I)
		WHILE ENTRY NE 0
		DO
			WRITE LEXEME(ENTRY) AS B 6, T *
			LET RULE = F_ENTRULES(ENTRY)
			WHILE RULE NE 0
			DO
				WRITE RULENAME(RULE) AS B 20, T *
				WRITE LEXEME(DICTENT(F_ALTS(F_PARTS(RULE)))) AS B 36, T *, /
				LET RULE = S_ENTRULES(RULE)
			LOOP
			WRITE AS /
			ENTRY = S_DICT(ENTRY)
		LOOP
	ELSE
		WRITE "None" AS B 6, T *, /
	ENDIF
LOOP
Function EASECOMPILE E PROJDIR SYSDIR ALINE APROC ANERR ERR
OPEN 97 FOR OUTPUT, NAME IS "Xlogtrans.txt"
USE 97 FOR OUTPUT
IF WOPENERR.V NE 0
	RETURN WITH -3
ENDIF
WRITE AS "logging translate...", /, /
IF INITERRS(SYSDIR) NE 0
	CLOSE 97
	RETURN WITH -1
ENDIF
RESERVE LOGICOPS AS 6		'' do this somewhere else... **********
LET LOGICOPS(1) = " == "
LET LOGICOPS(2) = " != "
LET LOGICOPS(3) = " <= "
LET LOGICOPS(4) = " >= "
LET LOGICOPS(5) = " < "
LET LOGICOPS(6) = " > "
CALL INITLEX(SYSDIR)
RESERVE CTLSTATES AS 2 BY 4
'' state 2 = collecting control phrases; state table used by parser
'' stmt types: 1 executable; 2 control; 3 declaration; 4 DO/FIND
LET CTLSTATES(1, 1) = 1
LET CTLSTATES(1, 2) = 2
LET CTLSTATES(1, 3) = 1
LET CTLSTATES(1, 4) = 1
LET CTLSTATES(2, 1) = 4
LET CTLSTATES(2, 2) = 2
LET CTLSTATES(2, 3) = 2
LET CTLSTATES(2, 4) = 1
CALL READSYNTAX(CONCAT.F(SYSDIR, "\\syntaxrules.txt"))
'' CALL LISTSYNTAX
CALL READSCRIPTS(CONCAT.F(SYSDIR, "\\scriptrules.txt"))
'' CALL READSOURCE
CALL READXML(CONCAT.F(SYSDIR, "\\easetypes.xml"), 0)
CALL READXML(CONCAT.F(SYSDIR, "\\easelibsys.xml"), 0)
OPEN 5 FOR INPUT, NAME IS CONCAT.F(PROJDIR, "\\project.eas")
USE 5 FOR INPUT
IF ROPENERR.V NE 0
	CLOSE 97
	RETURN WITH -2
ENDIF
LET EOF.V = 1
READ GENDIR AS T RRECLEN.V, /
WHILE EOF.V NE 2
DO
	READ ALINE
	READ AS /
	IF ALINE NE ""
		CALL READXML(PROJDIR, ALINE)
	ENDIF
LOOP
CLOSE 5
OPEN 98 FOR OUTPUT, NAME IS CONCAT.F(GENDIR, "XLISTING.txt")
CALL FIXUPSCHEMAS
CALL TRANSLATEPROCS
''CALL LISTING
CLOSE 98
CLOSE 97
IF F.ERRORRECS NE 0
	OPEN 99 FOR OUTPUT, NAME IS CONCAT.F(GENDIR, "XERRORS.txt")
	USE 99 FOR OUTPUT
	LET ANERR = F.ERRORRECS
	WHILE ANERR NE 0
	DO
		LET ERR = ERRNUM(ANERR)
		IF ERR GT 0
			WRITE AS "Error "
		ELSE
			LET ERR = -ERR
			WRITE AS "Warning "
		ENDIF
		WRITE ERR AS I 5
		IF INPROC(ANERR) NE 0
		WRITE LEXEME(PDICTREF(INPROC(ANERR))), LINENUM(ANERR)
			AS " in procedure ", T *, " line ", I 4
		ENDIF
		WRITE ERRMSGS(ERR-1000) AS S 2, T *, /
		LET ANERR = S.ERRORRECS(ANERR)
	LOOP
	CLOSE 99
	RETURN WITH 1
ENDIF
RETURN WITH 0 
END
Function FINDMODE_F M ETYPE
IF ETYPENAME(ETYPE) = "Integer"
	RETURN WITH .MODE.INT
ENDIF
IF ETYPENAME(ETYPE) = "Real"
	RETURN WITH .MODE.NMBR
ENDIF
IF ETYPENAME(ETYPE) = "Text"
	RETURN WITH .MODE.TXT
ENDIF
RETURN WITH .MODE.REF	''ref
END
Routine LISTENTITIES DATTR ANAME ETYPE ASCHEMA
OPEN 7 FOR OUTPUT, NAME IS "C:\\EASEsysdata\\entitylist.txt"
USE 7 FOR OUTPUT
WRITE " ****  Entity Definitions ****" AS T *, /
LET ASCHEMA = F.SCHEMAS
WHILE ASCHEMA NE 0
DO
	WRITE AS /
	WRITE " ** Schema name: " AS T *
	WRITE GENNAME(ASCHEMA) AS T *
''	IF ISSYSDEF(ASCHEMA) NE 0
''		WRITE "  (EASE System-defined)" AS T *
''	ENDIF
	WRITE AS /
	
	LET ETYPE = F.ETYPES(ASCHEMA)
	WHILE ETYPE NE 0
	DO
		WRITE ETYPENAME(ETYPE) AS B 2, T *
		WRITE AS /
		LET DATTR = F.ATTRDEFS(ETYPE)
		IF ISPROC(ETYPE) EQ 0 		'' **************************
			WHILE DATTR NE 0
			DO	
				WRITE ATTRNAME(DATTR) AS B 6, T *
				WRITE AS B 26
				IF ATTRTYPE(DATTR) NE 0
					WRITE ETYPENAME(ATTRTYPE(DATTR)) AS T *
				ELSE
					WRITE "Unknown - " AS T *
				ENDIF
				WRITE AS /
				LET DATTR = S.ATTRDEFS(DATTR)
			LOOP
		ENDIF						'' **************************
		LET ETYPE = S.ETYPES(ETYPE)
	LOOP
	LET ASCHEMA = S.SCHEMAS(ASCHEMA)
LOOP
CLOSE 7
RETURN
Function FINDSET_F S ANAME SID ETYPE SDEF
'' find set definition matching given name (and ss_id?)
LET SDEF = F.SETDEFS
WHILE SDEF NE 0
DO
	IF SETNAME(SDEF) EQ ANAME
		RETURN WITH SDEF
	ENDIF
	LET SDEF = S.SETDEFS(SDEF)
LOOP
RETURN WITH 0
END
Function FINDETYPEBYNAME_F E ANAME SID ETYPE ASCHEMA FOUND
'' find entity type from name - with precedence for given schema
LET ASCHEMA = F.SCHEMAS
WHILE ASCHEMA NE 0
DO
	LET ETYPE = F.ETYPES(ASCHEMA)
	WHILE ETYPE NE 0
	DO
		IF ETYPENAME(ETYPE) = ANAME
			LET FOUND = ETYPE
			IF SCHEMAID(ASCHEMA) = SID
				RETURN WITH ETYPE	'' look no further
			ENDIF
		ENDIF
		LET ETYPE = S.ETYPES(ETYPE)
	LOOP
	LET ASCHEMA = S.SCHEMAS(ASCHEMA)
LOOP
RETURN WITH FOUND
END
Routine MAKESETMMBRATTR PREFIX ETYPE MODE SDEF DREF DUSE AUSE
LET DREF = FINDDICTENTRY.F(CONCAT.F(PREFIX, SETNAME(SDEF)))
LET AUSE = FINDSPECUSE.F(DREF, .USE.MATTR)
LET DUSE = MAKEUSE.F(DREF, .USE.MATTR)
IF AUSE NE 0
	LET ISCOMMONATT(AUSE) = 1
	LET ISCOMMONATT(DUSE) = 1
ENDIF
LET USEOWNER(DUSE) = ETYPE
LET USEMODE(DUSE) = MODE
LET USESETDEF(DUSE) = SDEF
RETURN END
Routine MAKESETOWNRATTR PREFIX ATTR MODE DREF DUSE AUSE
LET DREF = FINDDICTENTRY.F(CONCAT.F(PREFIX, ATTRNAME(ATTR)))
LET AUSE = FINDSPECUSE.F(DREF, .USE.OATTR)
LET DUSE = MAKEUSE.F(DREF, .USE.OATTR)
IF AUSE NE 0
	LET ISCOMMONATT(AUSE) = 1
	LET ISCOMMONATT(DUSE) = 1
ENDIF
LET USEOWNER(DUSE) = OWNERTYPE(ATTR)
LET USEMODE(DUSE) = MODE
LET USESETREFATT(DUSE) = ATTR
RETURN END
Routine SYSSETSINIT SYSETYPE SYSNAME ATT APROC
'' Generate routine to create system-owned sets
LET SYSETYPE = F.SYSTEMS
WHILE SYSETYPE NE 0
DO
	LET SCRIPTLEVEL = 1
	LET SYSNAME = GENNAME(SCHEMAREF(SYSETYPE))
	LET APROC = MAKEPROC.F(CONCAT.F(SYSNAME, "_sets"), SCHEMAREF(SYSETYPE), 0)
	LET ATT = F.ATTRDEFS(SYSETYPE)
	WHILE ATT NE 0
	DO
		IF ISSETTYPE(ATTRTYPE(ATT)) NE 0
			LET STRPTRS(2) = ATTRNAME(ATT)
			IF ISPERSISTENT(ATTRTYPE(ATT)) NE 0
				CALL SCRIPT(73)
			ELSE
				CALL SCRIPT(72)
			ENDIF
		ENDIF
		LET ATT = S.ATTRDEFS(ATT)
	LOOP
	LET F.SCRIPTTOKENS(APROC) = F.TOKENLIST
	LET L_SCRIPTTOKENS(APROC) = L.TOKENLIST
	LET F.TOKENLIST = 0
	LET L.TOKENLIST = 0
	LET SCRIPTLEVEL = 0
	LET SYSETYPE = S.ETYPES(SYSETYPE)
LOOP
RETURN END
Routine SETSWRAPUP ETYPE SDEF MREF
'' add synthesized set membership attributes
LET SDEF = F.SETDEFS
WHILE SDEF NE 0
DO
	LET MREF = F.SETMMBRREFS(SDEF)
	WHILE MREF NE 0
	DO
		LET ETYPE = MMBRENT(MREF)
		CALL MAKESETMMBRATTR("P_", ETYPE, .MODE.REF, SDEF)
		CALL MAKESETMMBRATTR("S_", ETYPE, .MODE.REF, SDEF)
		CALL MAKESETMMBRATTR("M_", ETYPE, .MODE.INT, SDEF)
		LET MREF = S.SETMMBRREFS(MREF)
	LOOP
	IF SETDISCIPLINE(SDEF) EQ 0
		CALL ATTRRANKRTN(ETYPE, SDEF)
	ENDIF
	LET SDEF = S.SETDEFS(SDEF)
LOOP
RETURN END
Routine ENTSWRAPUP ETYPE ASCHEMA
'' script create/destroy routines
LET ASCHEMA = F.SCHEMAS
WHILE ASCHEMA NE 0
DO
	IF NOGEN(ASCHEMA) EQ 0
		LET ETYPE = F.ETYPES(ASCHEMA)
		WHILE ETYPE NE 0
		DO
			IF ISPROC(ETYPE) EQ 0
				CALL CRERTN(ETYPE)
				CALL DESRTN(ETYPE)
			ENDIF
			LET ETYPE = S.ETYPES(ETYPE)
		LOOP
	ENDIF
	LET ASCHEMA = S.SCHEMAS(ASCHEMA)
LOOP
RETURN END
Routine DESRTN ETYPE APROC ATT
LET SCRIPTLEVEL = 1
LET APROC = MAKEPROC.F(CONCAT.F("d_",ETYPENAME(ETYPE)), SCHEMAREF(ETYPE), 0)
LET STRPTRS(1) = "EPTR"
CALL ADDPARM(APROC, ETYPE, STRPTRS(1), 0, 1)
LET ATT = F.ATTRDEFS(ETYPE)
WHILE ATT NE 0
DO
	IF ETYPENAME(ATTRTYPE(ATT)) = "Text"
		LET STRPTRS(2) = ATTRNAME(ATT)
		CALL SCRIPT(28)
	ENDIF
	IF ISSETTYPE(ATTRTYPE(ATT)) NE 0 AND ISHIDDEN(ETYPE) EQ 0
		LET STRPTRS(2) = ATTRNAME(ATT)
		IF ISPERSISTENT(ATTRTYPE(ATT)) NE 0
			CALL SCRIPT(59)
		ELSE
			CALL SCRIPT(33)
		ENDIF
	ENDIF
	LET ATT = S.ATTRDEFS(ATT)
LOOP
IF ISPERSISTENT(ETYPE) NE 0
	CALL SCRIPT(56)
ELSE
	CALL SCRIPT(29)
ENDIF
LET F.SCRIPTTOKENS(APROC) = F.TOKENLIST
LET L_SCRIPTTOKENS(APROC) = L.TOKENLIST
LET F.TOKENLIST = 0
LET L.TOKENLIST = 0
LET SCRIPTLEVEL = 0
RETURN END
Routine CRERTN ETYPE RTYPE APROC ATT
LET SCRIPTLEVEL = 1
IF ISPERSISTENT(ETYPE) NE 0
	LET RTYPE = FINDETYPEBYNAME.F("iRef", 1)
ELSE
	LET RTYPE = ETYPE
ENDIF
LET APROC = MAKEPROC.F(CONCAT.F("c_",ETYPENAME(ETYPE)), SCHEMAREF(ETYPE), RTYPE)
CALL ADDLCL(APROC, RTYPE, "EPTR", 0)
LET STRPTRS(1) = ETYPENAME(ETYPE)
LET IPTRS(1) = SCHEMAID(SCHEMAREF(ETYPE))
LET IPTRS(2) = ETYPEID(ETYPE)
IF ISPERSISTENT(ETYPE) NE 0
	CALL SCRIPT(46)
ELSE
	CALL SCRIPT(30)
ENDIF
LET STRPTRS(1) = "EPTR"
IF ISHIDDEN(ETYPE) EQ 0
	LET ATT = F.ATTRDEFS(ETYPE)
	WHILE ATT NE 0
	DO		'' init set attribute
		IF ISSETTYPE(ATTRTYPE(ATT)) NE 0
			LET STRPTRS(2) = ATTRNAME(ATT)
			LET IPTRS(3) = SCHEMAID(SCHEMAREF(ATTRTYPE(ATT)))
			LET IPTRS(4) = ETYPEID(ATTRTYPE(ATT))
			IF ISPERSISTENT(ATTRTYPE(ATT)) NE 0
				CALL SCRIPT(47)
			ELSE
				CALL SCRIPT(31)
			ENDIF
		ENDIF
		LET ATT = S.ATTRDEFS(ATT)
	LOOP
ENDIF
CALL SCRIPT(32)
LET F.SCRIPTTOKENS(APROC) = F.TOKENLIST
LET L_SCRIPTTOKENS(APROC) = L.TOKENLIST
LET F.TOKENLIST = 0
LET L.TOKENLIST = 0
LET SCRIPTLEVEL = 0
RETURN END
Routine ATTRRANKRTN ETYPE SDEF PTYPE STYPE APROC RANKATTR
LET SCRIPTLEVEL = 1
LET PTYPE = FINDETYPEBYNAME.F("Integer", 1)
LET APROC = MAKEPROC_F(CONCAT.F("X_", SETNAME(SDEF)), SCHEMAREF(ETYPE), PTYPE)
LET STRPTRS(1) = "E1"
LET STRPTRS(2) = "E2"
LET PTYPE = FINDETYPEBYNAME.F("Reference", 1)
CALL ADDPARM(APROC, PTYPE, STRPTRS(2), 0, 0)
CALL ADDPARM(APROC, PTYPE, STRPTRS(1), 0, 0)
LET STRPTRS(3) = ETYPENAME(ETYPE)
CALL SCRIPT(43)
LET RANKATTR = F.RANKATTRS(SDEF)
WHILE RANKATTR NE 0
DO
	LET STRPTRS(4) = RATTRNAME(RANKATTR)
	CALL SCRIPT(44)
	LET RANKATTR = S.RANKATTRS(RANKATTR)
LOOP
CALL SCRIPT(45)
LET F.SCRIPTTOKENS(APROC) = F.TOKENLIST
LET L_SCRIPTTOKENS(APROC) = L.TOKENLIST
LET F.TOKENLIST = 0
LET L.TOKENLIST = 0
LET SCRIPTLEVEL = 0
RETURN END
Routine ADDLCL APROC TYPE ANAME SUBS RTN AUSE ATT
CREATE A ATTRDEF CALLED ATT
LET ATTRNAME(ATT) = ANAME
LET ATTRTYPE(ATT) = TYPE
LET SUBSCRIPTS(ATT) = SUBS
LET AUSE = FINDSPECUSE.F(PDICTREF(APROC), .USE.PROC)
LET RTN = USEENTITY(AUSE)
LET S.ATTRDEFS(ATT) = F.ATTRDEFS(RTN)
LET F.ATTRDEFS(RTN) = ATT
RETURN END
Routine ADDPARM APROC TYPE PNAME SUBS YLD RTN AUSE PARM
CREATE A ATTRDEF CALLED PARM
LET ATTRNAME(PARM) = PNAME
LET ATTRTYPE(PARM) = TYPE
LET SUBSCRIPTS(PARM) = SUBS
LET ISPARAM(PARM) = 1
LET ISYIELD(PARM) = YLD
LET AUSE = FINDSPECUSE.F(PDICTREF(APROC), .USE.PROC)
LET RTN = USEENTITY(AUSE)
LET S.ATTRDEFS(PARM) = F.ATTRDEFS(RTN)
LET F.ATTRDEFS(RTN) = PARM
RETURN END
Function MAKEPROC_F RET RNAME ASCHEMA RTYPE RTN APROC AUSE DREF RATT
CREATE A ENTITYTYPE CALLED RTN
LET S.ETYPES(RTN) = F.ETYPES(ASCHEMA)
LET F.ETYPES(ASCHEMA) = RTN
LET SCHEMAREF(RTN) = ASCHEMA
LET ISPROC(RTN) = 1
LET ETYPENAME(RTN) = RNAME
LET DREF = FINDDICTENTRY.F(RNAME)
LET AUSE = MAKEUSE.F(DREF, .USE.PROC)
LET USEENTITY(AUSE) = RTN
CREATE A EASEPROC CALLED APROC
LET PDICTREF(APROC) = DREF
LET S.PROCS(APROC) = F.PROCS(ASCHEMA)
LET F.PROCS(ASCHEMA) = APROC
IF RTYPE NE 0
	CREATE A ATTRDEF CALLED RATT
	LET ISRETTYPE(RATT) = 1
	LET ATTRNAME(RATT) = "rval"
	LET ATTRTYPE(RATT) = RTYPE
	LET F.ATTRDEFS(RTN) = RATT
	LET RETURNATT(APROC) = RATT
ENDIF
RETURN WITH APROC
END
Routine FIXUPSCHEMAS AFIX DATTR ETYPE DREF AUSE AUSE2 SETREF MREF SDEF DEAD
RESERVE E_BUILTINS AS 13		 '' probably should init from a file.. targetName, also
LET E_BUILTINS(1) = FINDETYPEBYNAME.F("Integer", 1)
LET E_BUILTINS(2) = FINDETYPEBYNAME.F("Real", 1)
LET E_BUILTINS(3) = FINDETYPEBYNAME.F("Text", 1)
LET E_BUILTINS(4) = FINDETYPEBYNAME.F("Reference", 1)
LET E_BUILTINS(5) = FINDETYPEBYNAME.F("iRef", 1)
LET E_BUILTINS(6) = FINDETYPEBYNAME.F("Subprogram", 1)
LET E_BUILTINS(12) = FINDETYPEBYNAME.F("E_SET", 1)
LET E_BUILTINS(13) = FINDETYPEBYNAME.F("E_PSET", 1)
'' get set ownership attribute type-name from set definitions
LET AFIX = F.SETOWNRFIXUPS
WHILE AFIX NE 0
DO
	LET SDEF = FINDSET.F(ATTRNAME(ATTREF(AFIX)), DBID(AFIX))
	IF ISPERSISTENT(SDEF) EQ 0
		LET ENTREFNAME(AFIX) = ETYPENAME(E_BUILTINS(12))
	ELSE
		LET ENTREFNAME(AFIX) = ETYPENAME(E_BUILTINS(13))
	ENDIF
	LET SETATTRSETDEF(ATTREF(AFIX)) = SDEF
	LET FIXUP = AFIX						'' save this..
	LET AFIX = S.FIXUPS(AFIX)
	LET S.FIXUPS(FIXUP) = F.ATTRFIXUPS		'' ..and add into attribute fixup list
	LET F.ATTRFIXUPS = FIXUP
LOOP
'' resolve attribute-to-entitytype references
LET AFIX = F.ATTRFIXUPS
WHILE AFIX NE 0
DO
	LET DATTR = ATTREF(AFIX)
	LET ETYPE = FINDETYPEBYNAME_F(ENTREFNAME(AFIX), DBID(AFIX))
	IF ETYPE EQ 0
		CALL EASERR(-1002, ENTREFNAME(AFIX))
		LET ETYPE = E_BUILTINS(1)
	ENDIF
	LET ATTRTYPE(DATTR) = ETYPE
	LET DREF = FINDDICTENTRY_F(ATTRNAME(DATTR))
	IF ISPROC(OWNERTYPE(DATTR)) EQ 0
		LET AUSE2 = FINDSPECUSE_F(DREF, .USE.ATTR)
		LET AUSE = MAKEUSE_F(DREF, .USE.ATTR)
		IF AUSE2 NE 0
			LET ISCOMMONATT(AUSE) = 1
			LET ISCOMMONATT(AUSE2) = 1
		ENDIF
		LET USEOWNER(AUSE) = OWNERTYPE(DATTR)
		LET USEENTITY(AUSE) = ETYPE
		LET USESUBS(AUSE) = SUBSCRIPTS(DATTR)
		LET USEMODE(AUSE) = FINDMODE.F(ETYPE)
		IF ISSETTYPE(ETYPE) NE 0
			LET USESETREFATT(AUSE) = DATTR
			CALL MAKESETOWNRATTR("F_", DATTR, .MODE.REF)
			CALL MAKESETOWNRATTR("L_", DATTR, .MODE.REF)
			CALL MAKESETOWNRATTR("N_", DATTR, .MODE.INT)
		ENDIF
	ELSE
		IF ISRETTYPE(DATTR) NE 0				'' function mode
			LET DREF = FINDDICTENTRY.F(ETYPENAME(OWNERTYPE(DATTR)))
			LET AUSE = FINDSPECUSE.F(DREF, .USE.PROC)
			LET USEMODE(AUSE) = FINDMODE.F(ETYPE)
		ENDIF
	ENDIF
	LET DEAD = AFIX
	LET AFIX = S.FIXUPS(AFIX)
	DESTROY FIXUP CALLED DEAD
LOOP
LET F.ATTRFIXUPS = 0
LET AFIX = F.SETMMBRFIXUPS
WHILE AFIX NE 0
DO
	LET SETREF = SETATTREF(AFIX)
	LET SDEF = FINDSET.F(SETATTNAME(SETREF), DBID(SETREF))
	CREATE A SETMMBRREF CALLED MREF
	LET S.SETMMBRREFS(MREF) = F.SETMMBRREFS(SDEF)
	LET F.SETMMBRREFS(SDEF) = MREF
	LET MMBRENT(MREF) = FIXMMBRENTREF(AFIX)
	LET DEAD = AFIX
	LET AFIX = S.FIXUPS(AFIX)
	DESTROY FIXUP CALLED DEAD
LOOP
CALL ENTSWRAPUP
CALL SETSWRAPUP
CALL SYSSETSINIT
RETURN END
Function FIXNAME_F N ATTNAME LEN I
'' this really ought to uppercase - but I need to fix 'built-ins' - Integer. Text etc.
LET LEN = LENGTH.F(ATTNAME)
FOR I = 1 TO LEN
DO
	IF ACHAR.F(ATTNAME, I) = .CH.PERIOD
		LET ACHAR.F(ATTNAME, I) = .CH.USCORE
	ENDIF
LOOP
RETURN WITH ATTNAME
Function READXMLENT_F E ASCHEMA AINT ATXT ETYPE DATTR LATTR SDEF SETREF AFIX RANKATTR
	'' read one entity description 
	CREATE AN ENTITYTYPE CALLED ETYPE
	LET ETYPEID(ETYPE) = XMLIATTR.F("ID")
	IF XMLLATTR.F("isSystemDefined") NE 0
		LET ISSETTYPE(ETYPE) = XMLLATTR.F("isSetType")
		LET ISHIDDEN(ETYPE) = XMLLATTR.F("isHidden")
		LET TARGETNAME(ETYPE) = XMLTATTR.F("targetName")
	ENDIF
	LET ISPROC(ETYPE) = XMLLATTR.F("isProcedure")
	LET ISPERSISTENT(ETYPE) = XMLLATTR.F("isPersistent")
	CALL XMLINTO
	IF XMLFINDELEM.F("entityTypeName") NE 0
		LET ETYPENAME(ETYPE) = XMLGETDATA.F
	ENDIF
	IF ISPROC(ETYPE) NE 0
		IF XMLFINDELEM.F("Body") NE 0
			LET PROCBODY(ETYPE) = XMLGETDATA.F
		ENDIF
	ENDIF
	
	LET LATTR = 0
	WHILE XMLFINDELEM.F("attrDef") NE 0
	DO
		CREATE AN ATTRDEF CALLED DATTR
		IF F.ATTRDEFS(ETYPE) = 0		'' keep args in order
			LET F.ATTRDEFS(ETYPE) = DATTR
		ELSE
			LET S.ATTRDEFS(LATTR) = DATTR
		ENDIF
		LET LATTR = DATTR
		LET OWNERTYPE(DATTR) = ETYPE
		LET ISEMBED(DATTR) = XMLLATTR.F("embedded")
		LET ISPARAM(DATTR) = XMLLATTR.F("parameter")
		LET ISYIELD(DATTR) = XMLLATTR.F("yielded")
		LET ISRETTYPE(DATTR) = XMLLATTR.F("returntype")
		LET SUBSCRIPTS(DATTR) = XMLIATTR.F("subscripts")
		IF XMLFINDCHILD.F("attrName") NE 0
			LET ATTRNAME(DATTR) = FIXNAME.F(XMLGETCHILDDATA.F)
		ENDIF
		IF XMLFINDCHILD.F("attrTypeName") NE 0
			CREATE A FIXUP CALLED AFIX
			LET ATTREF(AFIX) = DATTR
			LET ENTREFNAME(AFIX) = FIXNAME.F(XMLGETCHILDDATA.F)
			LET DBID(AFIX) = SCHEMAID(ASCHEMA)
			LET S.FIXUPS(AFIX) = F.ATTRFIXUPS
			LET F.ATTRFIXUPS = AFIX
		ENDIF
	LOOP
	
	WHILE XMLFINDELEM_F("setOwnDef") NE 0
	DO
		CREATE AN ATTRDEF CALLED DATTR			'' implementing ownership as reference attribute
		LET ATTRNAME(DATTR) = FIXNAME.F(XMLGETDATA.F)
		IF F.ATTRDEFS(ETYPE) = 0
			LET F.ATTRDEFS(ETYPE) = DATTR
		ELSE
			LET S.ATTRDEFS(LATTR) = DATTR
		ENDIF
		LET LATTR = DATTR
		LET OWNERTYPE(DATTR) = ETYPE
		
		CREATE A FIXUP CALLED AFIX
		LET ATTREF(AFIX) = DATTR
		LET DBID(AFIX) = XMLIATTR.F("dbId")
		LET S.FIXUPS(AFIX) = F.SETOWNRFIXUPS
		LET F.SETOWNRFIXUPS = AFIX
	LOOP
	
	WHILE XMLFINDELEM_F("setBelongDef") NE 0
	DO
		CREATE A SETATTDEFREF CALLED SETREF
		LET SETATTNAME(SETREF) = FIXNAME.F(XMLGETDATA.F)
		LET DBID(SETREF) = XMLIATTR.F("dbId")
		CREATE A FIXUP CALLED AFIX
		LET SETATTREF(AFIX) = SETREF
		LET FIXMMBRENTREF(AFIX) = ETYPE
		LET S.FIXUPS(AFIX) = F.SETMMBRFIXUPS
		LET F.SETMMBRFIXUPS = AFIX
		'' LET DBID(AFIX) = SCHEMAID(ASCHEMA)
	LOOP
	CALL XMLOUTOF
	RETURN WITH ETYPE
	END
Routine READXML PATH FNAME XMLFILE AINT OK ATXT ASCHEMA LSCHEMA ETYPE APROC DREF AUSE ATT SDEF RANKATTR LRANKATTR
LET XMLFILE = PATH
IF FNAME NE 0					'' path is not a complete filename
	LET XMLFILE = CONCAT.F(PATH, FNAME)
	LET XMLFILE = CONCAT.F(XMLFILE, ".xml")
ENDIF	
LET OK = XMLOPEN.F(XMLFILE)
LET OK = XMLFINDELEM.F("EASE-Database")
CREATE A SCHEMA CALLED ASCHEMA
LET GENNAME(ASCHEMA) = FNAME
IF F.SCHEMAS EQ 0
	LET F.SCHEMAS = ASCHEMA
ELSE
	LET LSCHEMA = F.SCHEMAS
	WHILE S.SCHEMAS(LSCHEMA) NE 0
	DO
		LET LSCHEMA = S.SCHEMAS(LSCHEMA)
	LOOP
	LET S.SCHEMAS(LSCHEMA) = ASCHEMA
ENDIF
LET SCHEMAID(ASCHEMA) = XMLIATTR.F("ID")
IF XMLTATTR.F("noGen") NE ""
	LET NOGEN(ASCHEMA) = 1
ENDIF
IF XMLTATTR.F("noHdr") NE ""
	LET NOHDR(ASCHEMA) = 1
ENDIF
LET ATXT = XMLTATTR.F("genname")	'' generated name override?
IF ATXT NE 0
	LET GENNAME(ASCHEMA) = ATXT
ENDIF
CALL XMLINTO
IF XMLFINDELEM.F("ENTITIES") NE 0
	CALL XMLINTO
	WHILE XMLFINDELEM.F("entityType") NE 0
	DO
		LET ETYPE = READXMLENT.F(ASCHEMA)	'' read entity type data
		LET S.ETYPES(ETYPE) = F.ETYPES(ASCHEMA)
		LET F.ETYPES(ASCHEMA) = ETYPE
		LET SCHEMAREF(ETYPE) = ASCHEMA
		LET DREF = FINDDICTENTRY.F(ETYPENAME(ETYPE))
		IF ISPROC(ETYPE) NE 0
			CREATE AN EASEPROC CALLED APROC		'' auxiliary
			LET PDICTREF(APROC) = DREF
			LET S.PROCS(APROC) = F.PROCS(ASCHEMA)
			LET F.PROCS(ASCHEMA) = APROC
			LET AUSE = MAKEUSE.F(DREF, .USE.PROC)
			LET ATT = F.ATTRDEFS(ETYPE)
			WHILE ATT NE 0
			DO
				IF ISRETTYPE(ATT) NE 0
					LET RETURNATT(APROC) = ATT
					LEAVE
				ENDIF
				LET ATT = S.ATTRDEFS(ATT)
			LOOP
		ELSE
			LET AUSE = MAKEUSE.F(DREF, .USE.ENT)
			LET USEMODE(AUSE) = .MODE.REF
		ENDIF
		LET USEENTITY(AUSE) = ETYPE
	LOOP
	CALL XMLOUTOF
ENDIF
IF XMLFINDELEM.F("SETS") NE 0
	CALL XMLINTO
	WHILE XMLFINDELEM.F("setDef") NE 0
	DO
		CREATE A SETDEF CALLED SDEF
		LET S.SETDEFS(SDEF) = F.SETDEFS
		LET F.SETDEFS = SDEF
		LET ATXT = XMLTATTR.F("discipline")
		IF ATXT = "F"
			LET SETDISCIPLINE(SDEF) = 1
		ENDIF
		IF ATXT = "L"
			LET SETDISCIPLINE(SDEF) = 2
		ENDIF
		IF XMLTATTR.F("isPersistent") = "Y"
			ISPERSISTENT(SDEF) = 1
		ENDIF
		CALL XMLINTO
		IF XMLFINDELEM.F("setName") NE 0
			LET SETNAME(SDEF) = FIXNAME.F(XMLGETDATA.F)
		ENDIF
 		WHILE XMLFINDELEM_F("rankAttr") NE 0
		DO
			CREATE A RANKATTRDEF CALLED RANKATTR
			IF F.RANKATTRS(SDEF) EQ 0
				LET F.RANKATTRS(SDEF) = RANKATTR
			ELSE
				LET LRANKATTR = F.RANKATTRS(SDEF)
				WHILE S.RANKATTRS(LRANKATTR) NE 0
				DO	
					LET LRANKATTR = S.RANKATTRS(LRANKATTR)
				LOOP
				LET S.RANKATTRS(LRANKATTR) = RANKATTR
			ENDIF
			IF XMLIATTR.F("low") NE 0
				LET LO(RANKATTR) = 1
			ENDIF
			LET RATTRNAME(RANKATTR) = XMLGETDATA.F
		LOOP
		CALL XMLOUTOF
  LOOP
  CALL XMLOUTOF
ENDIF
IF XMLFINDELEM.F("SYSTEM") NE 0
	CALL XMLINTO
	IF XMLFINDELEM.F("entityType") NE 0
		LET ETYPE = READXMLENT.F(ASCHEMA)
		LET S.ETYPES(ETYPE) = F.SYSTEMS
		LET F.SYSTEMS = ETYPE
		LET SCHEMAREF(ETYPE) = ASCHEMA
		LET ETYPENAME(ETYPE) = GENNAME(ASCHEMA)	'' we may have many 'SYSTEM's
		LET THESYSTEM(ASCHEMA) = ETYPE
	ENDIF
	CALL XMLOUTOF
ENDIF
IF XMLFINDELEM.F("SUBST") NE 0				'' define to mean
	CALL XMLINTO
	WHILE XMLFINDELEM.F("d2m") NE 0
	DO
		ATXT = XMLTATTR.F("term")
		LET DREF = FINDDICTENTRY.F(ATXT)
		IF XMLFINDCHILD.F("substxt") NE 0
			LET ATXT = XMLGETCHILDDATA.F
			CALL ANALYZE(ATXT, LENGTH.F(ATXT), 1)
			LET F.SUBST(DREF) = F.TOKENLIST
			LET L.SUBST(DREF) = L.TOKENLIST
			LET F.TOKENLIST = 0
			LET L.TOKENLIST = 0
		ENDIF
	LOOP
	CALL XMLOUTOF
ENDIF
Routine INITLEX SYSDIR I J
RESERVE CHARTYPE AS 128
RESERVE NEXTSTATE AS 14 BY 8
RESERVE ACTION AS 14 BY 8
RESERVE TOKENFORM AS 14
OPEN 5 FOR INPUT, NAME IS CONCAT.F(SYSDIR, "\\lexer.dat")
USE 5 FOR INPUT
FOR I = 1 TO 128
DO
	READ CHARTYPE(I)
LOOP
FOR I = 1 TO 14
DO
	FOR J = 1 TO 8
	DO
		READ NEXTSTATE(I, J)
	LOOP
	READ AS /
LOOP
FOR I = 1 TO 14
DO
	FOR J = 1 TO 8
	DO
		READ ACTION(I, J)
	LOOP
LOOP
READ AS /
FOR I = 1 TO 14
DO
	READ TOKENFORM(I)
LOOP
CLOSE 5
OPEN 6 FOR OUTPUT, NAME IS CONCAT.F(SYSDIR, "\\vlexer.dat")	'' verify lex tables read correctly
USE 6 FOR OUTPUT
FOR I = 0 TO 7
DO
	FOR J = 1 TO 16
	DO
		WRITE CHARTYPE(I * 16 + J) AS I 1, S 2
	LOOP
	WRITE AS /
LOOP
WRITE AS /
FOR I = 1 TO 14
DO
	FOR J = 1 TO 8
	DO
		WRITE NEXTSTATE(I, J) AS I 2, S 2
	LOOP
	WRITE AS /
LOOP
WRITE AS /
FOR I = 1 TO 14
DO
	FOR J = 1 TO 8
	DO
		WRITE ACTION(I, J) AS I 1, S 2
	LOOP
	WRITE AS /
LOOP
WRITE AS /
FOR I = 1 TO 14
DO
	WRITE TOKENFORM(I) AS I 1, S 2
LOOP
WRITE AS /
CLOSE 6
RESERVE F.DICT AS 128
RETURN
Routine ANALYZE BUFFER BUFFERLEN SEEKDICT STARTPOS CURRPOS CTYPE THISCHAR CURRSTATE NXTSTATE ACTN TOKENTYPE
LET CURRPOS = 1
LET STARTPOS = 1
WHILE CURRPOS LE BUFFERLEN + 1
DO
	IF CURRPOS > BUFFERLEN
		LET CTYPE = 0			'' virtual space to end line
	ELSE
		LET THISCHAR = ACHAR.F(BUFFER, CURRPOS)
		IF THISCHAR > 127
			LET ACHAR.F(BUFFER, CURRPOS) = .CH.SPC
			LET THISCHAR = ACHAR.F(BUFFER, CURRPOS)
		ENDIF
		IF CURRSTATE NE 4 		'' string
		 AND (THISCHAR GT 96 AND THISCHAR LT 123)
			LET ACHAR.F(BUFFER, CURRPOS) = THISCHAR - 32	'' lower to upper
			LET THISCHAR = ACHAR.F(BUFFER, CURRPOS)
		ENDIF
		LET CTYPE = CHARTYPE(THISCHAR + 1)
	ENDIF
	LET NXTSTATE = NEXTSTATE(CURRSTATE+1, CTYPE+1)
	LET TOKENTYPE = TOKENFORM(CURRSTATE+1)
	LET ACTN = ACTION(CURRSTATE+1, CTYPE+1)
	IF ACTN = 0								'' space: advance scan
		STARTPOS = STARTPOS+1
		GO TO 'CONT'
	ENDIF
	IF ACTN = 1								'' maintain start and continue scan
		GO TO 'CONT'
	ENDIF
	IF ACTN = 2								'' make token; start new token search
		CALL MAKETOKEN(BUFFER, STARTPOS, CURRPOS-1, TOKENTYPE, SEEKDICT)
		LET STARTPOS = CURRPOS
		GO TO 'CONT'
	ENDIF
	IF ACTN = 3								'' as above..
		CALL MAKETOKEN(BUFFER, STARTPOS, CURRPOS-1, TOKENTYPE, SEEKDICT)
		LET STARTPOS = CURRPOS + 1			'' .. but discard space
		GO TO 'CONT'
	ENDIF
	IF ACTN = 4								'' punctuation..
		IF STARTPOS < CURRPOS				'' ..token in progress?
			CALL MAKETOKEN(BUFFER, STARTPOS, CURRPOS-1, TOKENTYPE, SEEKDICT)
		ENDIF
		CALL MAKETOKEN(BUFFER, CURRPOS, CURRPOS, .TKN.PUNCT, SEEKDICT)
		LET STARTPOS = CURRPOS + 1
		GO TO 'CONT'
	ENDIF
	IF ACTN = 5								'' quoted string completion - strip quotes 
		CALL MAKETOKEN(BUFFER, STARTPOS+1, CURRPOS-1, .TKN.QSTR, SEEKDICT)
		LET STARTPOS = CURRPOS + 1
		GO TO 'CONT'
	ENDIF
	IF ACTN = 6								'' exponentiation operator - double asterisk
		CALL MAKETOKEN(BUFFER, STARTPOS, CURRPOS, .TKN.PUNCT, SEEKDICT)
		LET STARTPOS = CURRPOS + 1
		GO TO 'CONT'
	ENDIF
	IF ACTN = 7								'' double apostrophe - discard comment
		LET STARTPOS = CURRPOS + 1
		GO TO 'CONT'
	ENDIF
  'CONT'
	LET CURRPOS = CURRPOS + 1
	LET CURRSTATE = NXTSTATE
LOOP
RETURN
Routine MAKETOKEN BUFF BEGIN END TTYPE SEEKDICT LEN ATOKEN
WHILE ACHAR.F(BUFF, END) EQ .CH.PERIOD
DO
	LET END = END - 1
LOOP
IF BEGIN > END
	IF TTYPE NE .TKN.QSTR
		RETURN
	ENDIF
	LET BEGIN = BEGIN - 1
	LET END = END + 1
ENDIF
LET LEN = END - BEGIN + 1
CREATE A TOKEN CALLED ATOKEN
LET LEXEME(ATOKEN) = SUBSTR.F(BUFF, BEGIN, LEN)
LET TOKENTYPE(ATOKEN) = TTYPE
IF TTYPE EQ .TKN.IDENT
	WHILE LEN GT 0
	DO
		IF ACHAR.F(LEXEME(ATOKEN), LEN) = .CH.PERIOD
			LET ACHAR.F(LEXEME(ATOKEN), LEN) = .CH.USCORE
		ENDIF
		LEN = LEN - 1
	LOOP
ENDIF
CALL FILETOKEN(ATOKEN)
IF SEEKDICT NE 0
	LET DICTREF(ATOKEN) = FINDDICTENTRY_F(LEXEME(ATOKEN))
ENDIF
RETURN
Routine FILETOKEN ATOKEN
IF F.TOKENLIST EQ 0
	LET F.TOKENLIST = ATOKEN
ELSE
	LET S.TOKENLIST(L.TOKENLIST) = ATOKEN
ENDIF
LET L.TOKENLIST = ATOKEN
RETURN
Function READPART APART PART
CREATE A RULEPART CALLED APART
IF LEXEME(CURRTOKEN) = "<" AND TOKENTYPE(CURRTOKEN) EQ 0
	LET REQUIRED(APART) = 1
	LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
	WHILE LEXEME(CURRTOKEN) NE ">" OR  TOKENTYPE(CURRTOKEN) NE 0
	DO
		CALL READALT(APART)
	LOOP
ELSE
	IF LEXEME(CURRTOKEN) = "("
		LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
		WHILE LEXEME(CURRTOKEN) NE ")"
		DO
			CALL READALT(APART)
		LOOP
	ENDIF
ENDIF
LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
IF LEXEME(CURRTOKEN) = "*"
	LET REPEATS(APART) = 1
	LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
ENDIF
RETURN WITH APART
Routine LINKSUBTOROOTENTRY ARULE APART AALT SPART LRULE AENTRY
LET APART = F.PARTS(ARULE)
WHILE APART NE 0
DO
	LET AALT = F.ALTS(APART)
	WHILE AALT NE 0
	DO
		IF TERMINALTYPE(AALT) EQ 5	'' KEYWORD
			LET AENTRY = DICTENT(AALT)
		ELSE
			LET SPART = F.PARTS(SUBRULE(AALT))
			LET AENTRY = DICTENT(F.ALTS(SPART))
		ENDIF
		IF F.ENTRULES(AENTRY) = 0
			LET F.ENTRULES(AENTRY) = ARULE
		ELSE
			LET LRULE = F.ENTRULES(AENTRY)
			WHILE S.ENTRULES(LRULE) NE 0
			DO
				LET LRULE  = S.ENTRULES(LRULE)
			LOOP
			LET S.ENTRULES(LRULE) = ARULE
		ENDIF
		LET AALT = S.ALTS(AALT)
	LOOP
	IF REQUIRED(APART) NE 0
		LET APART = 0
	ELSE
		LET APART = S.PARTS(APART)
	ENDIF
LOOP
RETURN
Routine FIXUPSUBRULES AREF ARULE AFIX
LET AFIX = F.RULFIXUPS
WHILE AFIX NE 0
DO
	LET AREF = F.ALTREFS(AFIX)
	WHILE AREF NE 0
	DO
		LET SUBRULE(ALTSUBRULE(AREF)) = THERULE(AFIX)
		LET AREF = S.ALTREFS(AREF)
	LOOP
	LET AFIX = S.RULFIXUPS(AFIX)
LOOP
LET ARULE = F.SYNRULES
WHILE ARULE NE 0
DO
	CALL LINKSUBTOROOTENTRY(ARULE)
	LET ARULE = S.SYNRULES(ARULE)
LOOP
RETURN
Routine READALT PART ALT LAST AREF AFIX
CREATE A ALTPART CALLED ALT
IF TOKENTYPE(CURRTOKEN) = .TKN.QSTR
	LET DICTENT(ALT) = FINDDICTENTRY.F(LEXEME(CURRTOKEN))
	LET TERMINALTYPE(ALT) = 5	'' KEYWORD
	IF LEXEME(S.TOKENLIST(CURRTOKEN)) = "&"
		LET DISCARD(ALT) = 1
		LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
	ENDIF
ELSE
	IF LEXEME(CURRTOKEN) = "@"
		LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
		IF LEXEME(CURRTOKEN) = "IDENT"
			LET TERMINALTYPE(ALT) = 3
		ENDIF
		IF LEXEME(CURRTOKEN) = "FLOAT"
			LET TERMINALTYPE(ALT) = 2
		ENDIF
		IF LEXEME(CURRTOKEN) = "INT"
			LET TERMINALTYPE(ALT) = 1
		ENDIF
		IF LEXEME(CURRTOKEN) = "STR"
			LET TERMINALTYPE(ALT) = 4
		ENDIF
	ELSE
		CREATE A ALTREF CALLED AREF
		LET ALTSUBRULE(AREF) = ALT
		LET AFIX = F.RULFIXUPS
		WHILE AFIX NE 0
		DO
			IF LEXEME(CURRTOKEN) = RULENAME(AFIX)
				LEAVE
			ENDIF
			LET AFIX = S.RULFIXUPS(AFIX)
		LOOP
		IF AFIX EQ 0
			CREATE A RULFIXUP CALLED AFIX
			RULENAME(AFIX) = LEXEME(CURRTOKEN)
			LET S.RULFIXUPS(AFIX) = F.RULFIXUPS
			LET F.RULFIXUPS = AFIX
		ELSE
			LET S.ALTREFS(AREF) = F.ALTREFS(AFIX)
		ENDIF
		LET F.ALTREFS(AFIX) = AREF
		IF LEXEME(S.TOKENLIST(CURRTOKEN)) = "&"
			LET DISCARD(ALT) = 1
			LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
		ENDIF
	ENDIF
ENDIF
CURRTOKEN = S.TOKENLIST(CURRTOKEN)
IF LEXEME(CURRTOKEN) = "#"
	CURRTOKEN = S.TOKENLIST(CURRTOKEN)
	SCRIPTREF(ALT) = ACHAR.F(LEXEME(CURRTOKEN), 1) - 48
	CURRTOKEN = S.TOKENLIST(CURRTOKEN)
ENDIF
IF F.ALTS(PART) = 0
	LET F.ALTS(PART) = ALT
	LET SEQNUM(ALT) = 1
ELSE
	LET LAST = F.ALTS(PART)
	WHILE S.ALTS(LAST) NE 0
	DO
		LET LAST = S.ALTS(LAST)
	LOOP
	LET S.ALTS(LAST) = ALT
	LET SEQNUM(ALT) = SEQNUM(LAST) + 1
ENDIF
RETURN
Routine READRULE ARULE APART AFIX LASTPART LAST CLEAN
CREATE A SYNRULE CALLED ARULE
LET RULENAME(ARULE) = LEXEME(CURRTOKEN)
LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
IF LEXEME(CURRTOKEN) = "~"
	LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
	LET KEYRULE(ARULE) = 0
	LET AFIX = F.RULFIXUPS
	WHILE AFIX NE 0
	DO
     IF RULENAME(ARULE) = RULENAME(AFIX)
       LEAVE
     ELSE
       LET AFIX = S.RULFIXUPS(AFIX)
     ENDIF
	LOOP
	IF AFIX = 0
     CREATE A RULFIXUP CALLED AFIX
     LET RULENAME(AFIX) = RULENAME(ARULE)
     LET S.RULFIXUPS(AFIX) = F.RULFIXUPS
     LET F.RULFIXUPS = AFIX  
	ENDIF
	LET THERULE(AFIX) = ARULE
ELSE
   LET KEYRULE(ARULE) = 1
   LET S.SYNRULES(ARULE) = F.SYNRULES
   LET F.SYNRULES = ARULE
   LET RULETYPE(ARULE) = 1		'' tentative
   IF TOKENTYPE(CURRTOKEN) = 1
     LET RULETYPE(ARULE) = ACHAR.F(LEXEME(CURRTOKEN), 1) - 48	'' digit char-to-int
     LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
   ENDIF
ENDIF
WHILE LEXEME(CURRTOKEN) NE "!"
DO
   LET APART = READPART
   IF F.PARTS(ARULE) = 0
     LET F.PARTS(ARULE) = APART
   ELSE
     LET LASTPART = F.PARTS(ARULE)
     WHILE S.PARTS(LASTPART) NE 0
     DO
       LET LASTPART = S.PARTS(LASTPART)
     LOOP
     LET S.PARTS(LASTPART) = APART
   ENDIF
LOOP
LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
IF CURRTOKEN NE 0
   IF LEXEME(CURRTOKEN) = "!"
     LET CURRTOKEN = S.TOKENLIST(CURRTOKEN)
     CALL FIXUPSUBRULES
   ENDIF
ENDIF
LET LAST = F.TOKENLIST
LET F.TOKENLIST = CURRTOKEN
WHILE LAST NE F.TOKENLIST
DO
   LET CLEAN = LAST
   LET LAST = S.TOKENLIST(LAST)
   LET LEXEME(CLEAN) = ""
   DESTROY TOKEN CALLED CLEAN
LOOP
RETURN
Routine READSYNTAX FILENAME RULELINE LEN APROC
OPEN 5 FOR INPUT, NAME IS FILENAME
USE 5 FOR INPUT
LET EOF.V = 1
WHILE EOF.V NE 2
DO
READ RULELINE AS T RRECLEN.V
LET LEN = LENGTH.F(RULELINE)
CALL ANALYZE(RULELINE, LEN, 0)
IF F.TOKENLIST NE 0
  LET CURRTOKEN = F.TOKENLIST
  CALL READRULE
ENDIF
READ AS /
LOOP
CLOSE 5
''CALL LISTSYNTAX
''CALL LISTENTITIES
Function FINDDICTENTRY_F RET INLEX INDEX ENTRY
LET INDEX = ACHAR.F(INLEX, 1)	'' very cheap hash!
LET ENTRY = F.DICT(INDEX)
WHILE ENTRY NE 0
DO
	IF LEXEME(ENTRY) = INLEX
		LEAVE
	ENDIF
	LET ENTRY = S.DICT(ENTRY)
LOOP
IF ENTRY EQ 0
	CREATE A DICTENTRY CALLED ENTRY
	LET LEXEME(ENTRY) = INLEX
	LET S.DICT(ENTRY) = F.DICT(INDEX)
	LET F.DICT(INDEX) = ENTRY
ENDIF
RETURN WITH ENTRY
Routine DESTROYUSE AUSE REF DUSE LUSE
LET REF = USEREF(AUSE)
LET DUSE = F.USAGE(REF)
WHILE DUSE NE 0
DO
	IF DUSE = AUSE
		IF LUSE NE 0
			LET S.USAGE(LUSE) = S.USAGE(DUSE)
		ELSE
			LET F.USAGE(REF) = S.USAGE(DUSE)
		ENDIF
		DESTROY DICTUSE CALLED AUSE
		LEAVE
	ENDIF
	LET LUSE = DUSE
	LET DUSE = S.USAGE(DUSE)
LOOP
RETURN
Function FINDPREFUSE_F RET TKN DREF MUSTHAVE DUSE
LET DREF = DICTREF(TKN)
LET DUSE = FINDSPECUSE_F(DREF, .USE.LCL)
IF DUSE EQ 0
	LET DUSE = F.USAGE(DREF)
	WHILE DUSE NE 0
	DO
		IF USETYPE(DUSE) LT .USE.LBL
			LEAVE
		ENDIF
		LET DUSE = S.USAGE(DUSE)
	LOOP
ENDIF
IF DUSE EQ 0 AND MUSTHAVE NE 0
	IF SCRIPTED(TKN) = 0
		CALL EASERR(1002, LEXEME(TKN))
	ENDIF
	LET DUSE = MAKEUSE_F(DREF, .USE.LCL)
	LET USEMODE(DUSE) = .MODE.INT
	LET USEENTITY(DUSE) = FINDETYPEBYNAME_F("Integer", 1)
ENDIF
RETURN WITH DUSE
Function FINDSPECUSE_F RET DREF TYPE DUSE
LET DUSE = F.USAGE(DREF)
WHILE DUSE NE 0
DO
	IF USETYPE(DUSE) EQ TYPE
		LEAVE
	ENDIF
	LET DUSE = S.USAGE(DUSE)
LOOP
RETURN WITH DUSE
Function MAKEUSE_F RET DREF TYPE DUSE
CREATE A DICTUSE CALLED DUSE
LET USETYPE(DUSE) = TYPE
LET S.USAGE(DUSE) = F.USAGE(DREF)
LET F.USAGE(DREF) = DUSE
LET USEREF(DUSE) = DREF
RETURN WITH DUSE
Function FINDLCLDEF RET VARNAME ALCL LAST
LET ALCL = F.LCLDEFS(CURRPROC)
WHILE ALCL NE 0
DO
	IF LDEFNAME(ALCL) EQ VARNAME
		LEAVE
	ENDIF
	LET LAST = ALCL
	LET ALCL = S.LCLDEFS(ALCL)
LOOP
IF ALCL EQ 0
	CREATE A LCLDEF CALLED ALCL
	IF LAST NE 0
		LET S.LCLDEFS(LAST) = ALCL
	ELSE
		LET F.LCLDEFS(CURRPROC) = ALCL
	ENDIF
	LET LDEFNAME(ALCL) = VARNAME
ENDIF
RETURN WITH ALCL
END
Routine UPDATELCL ALCL MODENODE DIMNODE AUSE
IF LDEFTYPE(ALCL) NE 0			'' redefinition?
	CALL EASERR(1019, LDEFNAME(ALCL))
	RETURN
ENDIF
IF MODENODE NE 0
	IF MATCHNUM(MODENODE) EQ 4 AND F.SUBNODES(MODENODE) NE 0		'' entity type reference
		LET AUSE = FINDSPECUSE.F(DICTREF(START(MODENODE)), .USE.ENT)
		IF AUSE EQ 0
			CALL EASERR(1002, LEXEME(START(MODENODE)))
		ELSE
			LET LDEFTYPE(ALCL) = USEENTITY(AUSE)
		ENDIF
	ELSE
		LET LDEFTYPE(ALCL) = E_BUILTINS(MATCHNUM(MODENODE))
	ENDIF
ENDIF
IF LDEFTYPE(ALCL) EQ 0
	CALL EASERR(-1002, LDEFNAME(ALCL))
	LET LDEFTYPE(ALCL) = E_BUILTINS(1)		'' default to Integer
ENDIF
IF DIMNODE NE 0
	LET LDEFDIM(ALCL) = ACHAR.F(LEXEME(START(DIMNODE)), 1) - 48		'' yes, this really crude
ENDIF
RETURN
Routine STMTDEFFUNC ASTMT ANODE ALCL VARNODE DREF AUSE RTYPE
LET ANODE = F.PARSENODES(ASTMT)
LET ANODE = S.NODES(ANODE)
IF ANODE NE L.PARSENODES(ASTMT)		'' given arguments
	LET VARNODE = F.SUBNODES(ANODE)
ENDIF
WHILE VARNODE NE 0
DO
	LET ALCL = FINDLCLDEF(LEXEME(START(F.SUBNODES(VARNODE))))
	LET LPARAM(ALCL) = 1
	LET VARNODE = S.NODES(VARNODE)
LOOP
LET ALCL = FINDLCLDEF("rval")	'' return specification
LET ANODE = F.SUBNODES(F.SUBNODES(L.PARSENODES(ASTMT)))		'' we could & varmode %%
IF MATCHNUM(ANODE) EQ 4 AND F.SUBNODES(ANODE) NE 0
	LET DREF = FINDDICTENTRY.F(LEXEME(START(ANODE)))
	LET AUSE = FINDSPECUSE.F(DREF, .USE.ENT)
	IF AUSE NE 0
		LET RTYPE = USEENTITY(AUSE)
	ENDIF
ELSE	
	LET RTYPE = E_BUILTINS(MATCHNUM(ANODE))
ENDIF
IF RTYPE EQ 0
	CALL EASERR(1002, LEXEME(START(ANODE)))
	LET RTYPE = E_BUILTINS(1)	'' presume Integer
ENDIF
LET LDEFTYPE(ALCL) = RTYPE
LET LRET(ALCL) = 1
RETURN
Routine STMTDEFRTN ASTMT ANODE ALCL VARNODE YLD
LET ANODE = F.PARSENODES(ASTMT)
LET ANODE = S.NODES(ANODE)
WHILE ANODE NE 0
DO
	LET VARNODE = F.SUBNODES(ANODE)
	IF SCRIPTCODE(VARNODE) NE 0
		LET YLD = 1
	ENDIF
	WHILE VARNODE NE 0
	DO
		LET ALCL = FINDLCLDEF(LEXEME(START(F.SUBNODES(VARNODE))))
		LET LPARAM(ALCL) = 1
		LET LYLD(ALCL) = YLD
		LET VARNODE = S.NODES(VARNODE)
	LOOP
	LET ANODE = S.NODES(ANODE)
LOOP
RETURN
Routine STMTDEFVAR ASTMT ANODE ALCL VARNODE MODENODE DIMNODE
LET ANODE = F.PARSENODES(ASTMT)
LET VARNODE = F.SUBNODES(ANODE)
LET ANODE = S.NODES(ANODE)
WHILE ANODE NE 0
DO
	IF MATCHNUM(ANODE) EQ 1
		LET DIMNODE = ANODE
	ELSE
		LET MODENODE = F.SUBNODES(ANODE)
	ENDIF
	LET ANODE = S.NODES(ANODE)
LOOP
WHILE VARNODE NE 0
DO
	LET ALCL = FINDLCLDEF(LEXEME(START(VARNODE)))
	CALL UPDATELCL(ALCL, MODENODE, DIMNODE)
	IF SCRIPTCODE(L.PARSENODES(ASTMT)) NE 0
		LET ISSUBPROG(ALCL) = 1
	ENDIF
	LET VARNODE = S.NODES(VARNODE)
LOOP
RETURN
Routine DESTROYNODES ANODE LASTNODE
IF ANODE = F.NODES
	LET F.NODES = 0
	LET LASTNODE = ANODE
ENDIF
WHILE ANODE NE 0
DO
	IF F.SUBNODES(ANODE) NE 0
		CALL DESTROYNODES(F.SUBNODES(ANODE))
	ENDIF
	LET LASTNODE = ANODE
	LET ANODE = S.NODES(ANODE)
	DESTROY NODE CALLED LASTNODE
LOOP
RETURN
Routine SUBSTITUT ATOKEN STOKEN DREF
WHILE ATOKEN NE 0
DO
	IF TOKENTYPE(ATOKEN) = .TKN.IDENT
		LET DREF = DICTREF(ATOKEN)
		IF F.SUBST(DREF) NE 0
			IF F.SUBST(DREF) = L.SUBST(DREF)	'' single Def2mean token
				LET STOKEN = F.SUBST(DREF)
				LET DICTREF(ATOKEN) = DICTREF(STOKEN)
				LET TOKENTYPE(ATOKEN) = TOKENTYPE(STOKEN)
				LET LEXEME(ATOKEN) = LEXEME(STOKEN)
			ENDIF
		ENDIF
	ENDIF 
	LET ATOKEN = S.TOKENLIST(ATOKEN)
LOOP
RETURN
Routine FILENODE ANODE
IF F.NODES = 0
	LET F.NODES = ANODE
ELSE
	LET S.NODES(L.NODES) = ANODE
ENDIF
LET L.NODES = ANODE
RETURN
Routine PARSE APROC LINE ATOKEN SAVEF SAVEL ASTMT N PFMT LFMT ARULE
LET SCRIPTLEVEL = 0
LET STMTSTATE = 1
WHILE F.TOKENLIST = 0
DO
	LET LINE = NEXTLINE.F
	IF LINE = 0
		RETURN
	ENDIF
	CALL ANALYZE(LINE, LENGTH_F(LINE), 1)
	CALL SUBSTITUT(F.TOKENLIST)
LOOP	
WHILE F.TOKENLIST NE 0
DO
	LET ATOKEN = F.TOKENLIST
	LET ASTMT = PARSESTMT_F
	IF ASTMT NE 0
''	write rulename(stmtrule(astmt)) as t *  write as /
		LET F.TOKENS(ASTMT) = ATOKEN		'' for debug printout...
		LET SCRIPTDEPTH(ASTMT) = SCRIPTED(ATOKEN)
		WHILE ATOKEN NE 0
		DO
			IF PARSED(ATOKEN) EQ 0
				LEAVE
			ENDIF
			LET LASTPARSED = ATOKEN
''			write lexeme(atoken) as t *
''			write as s 2
			LET ATOKEN = S.TOKENLIST(ATOKEN)
		LOOP
''		write as /
		L.TOKENS(ASTMT) = LASTPARSED
		
		IF SCRIPTDEPTH(ASTMT) EQ 0
			LET STMTSTATE = CTLSTATES(STMTSTATE, RULETYPE(STMTRULE(ASTMT)))	'' for non-DO looping
		ENDIF
		
		IF F.STMTS(APROC) EQ 0
			LET F.STMTS(APROC) = ASTMT
			LET STMTNUM(ASTMT) = 1
		ELSE
			LET S.STMTS(L_STMTS(APROC)) = ASTMT
			LET STMTNUM(ASTMT) = STMTNUM(L.STMTS(APROC)) + 1
		ENDIF
		LET P.STMTS(ASTMT) = L.STMTS(APROC)
		LET L.STMTS(APROC) = ASTMT
		IF RULENAME(STMTRULE(ASTMT)) = "MAIN"
			LET PDICTREF(APROC) = FINDDICTENTRY.F("MAIN")
			CALL STMTDEFRTN(ASTMT)
		ENDIF
		
		IF RULENAME(STMTRULE(ASTMT)) = "DCLRTN"
			CALL STMTDEFRTN(ASTMT)
		ENDIF
		IF RULENAME(STMTRULE(ASTMT)) = "DCLFUNC"
			CALL STMTDEFFUNC(ASTMT)
		ENDIF
		IF RULENAME(STMTRULE(ASTMT)) = "DEFVAR"
			CALL STMTDEFVAR(ASTMT)
		ENDIF
		
		IF RULENAME(STMTRULE(ASTMT)) = "PRINTN"
			IF MATCHNUM(F.PARSENODES(ASTMT)) = 2
				LET N = 1
			ELSE
				LET N = ACHAR.F(LEXEME(START(F.PARSENODES(ASTMT))), 1) - 48
			ENDIF
			WHILE N > 0
			DO
				LET N = N - 1
				CREATE A SRCLINE CALLED PFMT
				LET LTXT(PFMT) = NEXTLINE.F
				IF F.FMTLINES(ASTMT) EQ 0
					LET F.FMTLINES(ASTMT) = PFMT
				ELSE
					LET LFMT = F.FMTLINES(ASTMT)
					WHILE S.SRCLINES(LFMT) NE 0
					DO
						LET LFMT = S.SRCLINES(LFMT)
					LOOP
					LET S.SRCLINES(LFMT) = PFMT
				ENDIF
			LOOP
		ENDIF
		LET F.TOKENLIST = S.TOKENLIST(LASTPARSED)
		LET S.TOKENLIST(LASTPARSED) = 0
		IF F.TOKENLIST EQ 0
			LET L.TOKENLIST = 0
		ENDIF
		
		IF F.PARSENODES(ASTMT) NE 0
			LET SAVEF = F.TOKENLIST
			LET F.TOKENLIST = 0		'' give scripting an 'empty' token list
			LET SAVEL = L.TOKENLIST
			LET L.TOKENLIST = 0
			
			CALL STMTSCRIPT(ASTMT)	'' DO SCRIPTING HERE
			IF STMTSTATE EQ 4
				CALL SCRIPTLOOP
			ENDIF
			
			IF L.TOKENLIST NE 0
				LET S.TOKENLIST(L.TOKENLIST) = SAVEF
			ELSE
				LET F.TOKENLIST = SAVEF
			ENDIF
			IF SAVEL NE 0
				LET L.TOKENLIST = SAVEL
			ENDIF
		ENDIF
		
		IF STMTSTATE GT 2
			LET STMTSTATE = 1
		ENDIF
	ELSE
		CALL EASERR(1001, LEXEME(F.TOKENLIST))							'' syntax error
		LET ARULE = 0
		WHILE ARULE EQ 0
		DO
			LET F.TOKENLIST = S.TOKENLIST(F.TOKENLIST)	'' advance parse position
			WHILE F.TOKENLIST EQ 0
			DO
				LET LINE = NEXTLINE.F
				IF LINE = 0
					LEAVE
				ENDIF
				CALL ANALYZE(LINE, LENGTH_F(LINE), 1)
				CALL SUBSTITUT(F.TOKENLIST)
			LOOP
			IF F.TOKENLIST EQ 0
				LEAVE
			ENDIF
			LET ARULE = F.ENTRULES(DICTREF(F.TOKENLIST))
		LOOP
	ENDIF
	
	WHILE F.TOKENLIST = 0
	DO
		LET LINE = NEXTLINE.F
		IF LINE = 0
			LEAVE
		ENDIF
		CALL ANALYZE(LINE, LENGTH_F(LINE), 1)
		CALL SUBSTITUT(F.TOKENLIST)
	LOOP
	IF F.TOKENLIST = 0		'' no more source
		LET L.TOKENLIST = 0
	ENDIF
	
LOOP
RETURN
Function PARSESTMT_F RET ATOKEN AENTRY ARULE APART LINE ASTMT SUCCESS LASTCHANCE
''LET SUCCESS = 0
''LET LASTCHANCE = 0
LET PARSETOKEN = F.TOKENLIST
LET AENTRY = DICTREF(PARSETOKEN)
LET ARULE = F.ENTRULES(AENTRY)
IF ARULE EQ 0 AND TOKENTYPE(PARSETOKEN) = .TKN.IDENT
	LET LASTCHANCE = F.TOKENLIST
	LET AENTRY = FINDDICTENTRY_F("LET")	'' Glen Johnson's BASIC hail-mary fix
	CREATE A TOKEN CALLED PARSETOKEN
	LET DICTREF(PARSETOKEN) = AENTRY
	LET S.TOKENLIST(PARSETOKEN) = F.TOKENLIST
	LET F.TOKENLIST = PARSETOKEN
	LET ARULE = F.ENTRULES(AENTRY)
ENDIF	
WHILE ARULE NE 0
DO
	LET SUCCESS = MATCHRULE_F(ARULE)
	IF SUCCESS EQ 0
		CALL DESTROYNODES(F_NODES)
		IF LASTCHANCE NE 0
			LET F.TOKENLIST = S.TOKENLIST(LASTCHANCE)
			RETURN WITH 0
		ENDIF
		LET PARSETOKEN = F.TOKENLIST
		LET ARULE = S.ENTRULES(ARULE)
	ELSE
		CREATE A STMT CALLED ASTMT
		LET STMTRULE(ASTMT) = ARULE
		LET STMTLINE(ASTMT) = CURRLINE
		IF F.NODES NE 0
			LET F.PARSENODES(ASTMT) = F.NODES
			LET L.PARSENODES(ASTMT) = L.NODES
			LET F.NODES = 0
			LET L.NODES = 0
		ENDIF
		RETURN WITH ASTMT		'' success
	ENDIF
LOOP
RETURN WITH 0		'' no more rule choices
Function MATCHRULE_F RET ARULE APART SUCCESS FOUNDPART
LET APART = F.PARTS(ARULE)
WHILE APART NE 0
DO
	LET SUCCESS = MATCHRULEPART_F(APART)
	IF SUCCESS EQ 0
		IF REQUIRED(APART) NE 0
			LEAVE
		ELSE
			IF FOUNDPART NE 0
				LET SUCCESS = 1
			ENDIF
		ENDIF
	ELSE
		LET FOUNDPART = 1
	ENDIF
	APART = S.PARTS(APART)
LOOP	
RETURN WITH SUCCESS
Function MATCHRULEPART_F RET APART AALT SUCCESS FOUND1
LET AALT = F.ALTS(APART)
WHILE AALT NE 0
DO
	SUCCESS = MATCHPARTALT_F(AALT)
	IF SUCCESS NE 0
		IF REPEATS(APART) NE 0
			LET FOUND1 = 1
			WHILE SUCCESS NE 0
			DO
				LET SUCCESS = MATCHPARTALT_F(AALT)
			LOOP
			LET SUCCESS = FOUND1
		ENDIF
		LET AALT = 0
	ELSE
		LET AALT = S.ALTS(AALT)
	ENDIF
LOOP
RETURN WITH SUCCESS
Function MATCHPARTALT_F RET AALT ATOKEN LINE ANODE LASTNODE AENTRY TTYPE SUCCESS FOUND1
SUCCESS = 0
IF PARSETOKEN EQ 0
	ATOKEN = L.TOKENLIST
	WHILE S.TOKENLIST(ATOKEN) EQ 0
	DO
		LINE = NEXTLINE.F
		IF LINE EQ 0
			RETURN WITH SUCCESS
		ENDIF
		CALL ANALYZE(LINE, LENGTH_F(LINE), 1)
		CALL SUBSTITUT(F.TOKENLIST)
	LOOP
	PARSETOKEN = S.TOKENLIST(ATOKEN)
ENDIF
IF SUBRULE(AALT) NE 0
	LET LASTNODE = L.NODES
	LET ATOKEN = PARSETOKEN
	LET SUCCESS = MATCHRULE_F(SUBRULE(AALT))
	IF SUCCESS EQ 0
		LET PARSETOKEN = ATOKEN
		WHILE ATOKEN NE 0
		DO
			IF PARSED(ATOKEN) EQ 0
				LEAVE
			ENDIF
			LET PARSED(ATOKEN) = 0
			ATOKEN = S.TOKENLIST(ATOKEN)
		LOOP
		IF LASTNODE NE 0				'' some nodes created in error?
			IF L.NODES NE LASTNODE
				LET L.NODES = LASTNODE
				LET ANODE = S.NODES(L.NODES)
				LET S.NODES(L.NODES) = 0
				CALL DESTROYNODES(ANODE)
			ENDIF
		ELSE
			IF F.NODES != 0				'' the whole node tree is bad
				CALL DESTROYNODES(F.NODES)
				LET F.NODES = 0
				LET L.NODES = 0
			ENDIF
		ENDIF
	ELSE
		IF DISCARD(AALT) = 0
			CREATE A NODE CALLED ANODE
			LET START(ANODE) = ATOKEN
			WHILE ATOKEN NE 0
			DO
				IF PARSED(ATOKEN) EQ 0
					LEAVE
				ELSE
					LET END(ANODE) = ATOKEN
					ATOKEN = S.TOKENLIST(ATOKEN)
				ENDIF
			LOOP
			
			LET MATCHNUM(ANODE) = SEQNUM(AALT)
			LET SCRIPTCODE(ANODE) = SCRIPTREF(AALT)
			LET NODENAME(ANODE) = RULENAME(SUBRULE(AALT))	'' for debug
			CALL STRUCTNODES(ANODE, LASTNODE)
			CALL FILENODE(ANODE)
		ENDIF
	ENDIF
ELSE
	AENTRY = DICTREF(PARSETOKEN)
	TTYPE = TERMINALTYPE(AALT)
	IF TTYPE EQ 0
		IF DICTENT(AALT) = AENTRY
			GO TO 'MATCHED'
		ENDIF
	ENDIF
	
	IF TTYPE EQ 1
		IF TOKENTYPE(PARSETOKEN) = 1
			GO TO 'MATCHED'
		ENDIF
	ENDIF
	IF TTYPE EQ 2
		IF TOKENTYPE(PARSETOKEN) = 1
		 OR TOKENTYPE(PARSETOKEN) = 2
			GO TO 'MATCHED'
		ENDIF
	ENDIF
	IF TTYPE EQ 3
		IF TOKENTYPE(PARSETOKEN) = 3
			GO TO 'MATCHED'
		ENDIF
	ENDIF
	IF TTYPE EQ 4
		IF TOKENTYPE(PARSETOKEN) = 4
			GO TO 'MATCHED'
		ENDIF
	ENDIF
	IF TTYPE EQ 5
		IF DICTENT(AALT) = AENTRY
			GO TO 'MATCHED'
		ENDIF
	ENDIF
	RETURN WITH 0
  'MATCHED'
	SUCCESS = 1
	PARSED(PARSETOKEN) = 1
	IF DISCARD(AALT) = 0
		CREATE A NODE CALLED ANODE
		LET START(ANODE) = PARSETOKEN
		LET END(ANODE) = PARSETOKEN
		LET MATCHNUM(ANODE) = SEQNUM(AALT)
		LET SCRIPTCODE(ANODE) = SCRIPTREF(AALT)
		CALL FILENODE(ANODE)
	ENDIF
	LET PARSETOKEN = S.TOKENLIST(PARSETOKEN)
ENDIF
RETURN WITH SUCCESS
Routine STRUCTNODES ANODE LASTNODE
IF L.NODES NE LASTNODE	'' one or more nodes to form a subtree under ANODE
	IF LASTNODE EQ 0	'' this will be the first subtree
		LET F.SUBNODES(ANODE) = F.NODES	
		LET L.SUBNODES(ANODE) = L.NODES
		LET F.NODES = 0					'' filenode will reset these
		LET L.NODES = 0
	ELSE
		LET F.SUBNODES(ANODE) = S.NODES(LASTNODE)
		LET S.NODES(LASTNODE) = ANODE
		LET L.SUBNODES(ANODE) = L.NODES
		LET L.NODES = LASTNODE
	ENDIF
ENDIF
Function NEXTLINE_F RET LAST
IF CURRENTLINE EQ 0
	LET CURRENTLINE = F.SRCLINES
	LET CURRLINE = 1
ELSE
	LET CURRENTLINE = S.SRCLINES(CURRENTLINE)
	LET CURRLINE = CURRLINE + 1
ENDIF
IF CURRENTLINE EQ 0
	LET CURRLINE = 0
	CALL CLEARSRCLINES
	RETURN WITH ""
ELSE
	WRITE LTXT(CURRENTLINE) AS T *, / USING 98
	RETURN WITH LTXT(CURRENTLINE)
ENDIF
Routine CLEARSRCLINES LAST
LET CURRENTLINE = F.SRCLINES
LET F.SRCLINES = 0
WHILE CURRENTLINE NE 0
DO
	LET LAST = CURRENTLINE
	LET CURRENTLINE = S.SRCLINES(CURRENTLINE)
	ERASE LTXT(LAST)
	DESTROY SRCLINE CALLED LAST
LOOP
Routine BUILDSOURCE BODYTEXT ALINE LASTLINE TOTLEN LINELEN I START
CALL CLEARSRCLINES 
LET TOTLEN = LENGTH.F(BODYTEXT)
LET START = 1
FOR I = 1 TO TOTLEN
DO
	IF ACHAR.F(BODYTEXT, I) EQ 13	
		LET LINELEN = I - START
		IF LINELEN NE 0
			CREATE A SRCLINE CALLED ALINE
			LET LTXT(ALINE) = SUBSTR.F(BODYTEXT, START, LINELEN)
			IF F.SRCLINES EQ 0
				LET F.SRCLINES = ALINE
			ELSE
				LET S.SRCLINES(LASTLINE) = ALINE
			ENDIF
			LET LASTLINE = ALINE
			LET TOTLINES = TOTLINES + 1
		ENDIF
		LET START = I + 2	'' take both CR & LF
	ENDIF
LOOP
RETURN
Routine SCRIPTREAD ASTMT ANODE EXPNODE FMTNODE SCRIPTNUM MATCH AUSE AMODE ALCL HASUSING
LET ANODE = F.PARSENODES(ASTMT)
IF S.NODES(ANODE) NE 0		'' using clause
	LET HASUSING = 1
	CALL SCRIPT(61)
	LET IPTRS(1) = 1
	CALL SCRIPT(60)
ENDIF
IF MATCHNUM(ANODE) = 3		'' free-form read
	LET ANODE = F.SUBNODES(ANODE)
	WHILE ANODE NE 0
	DO
		LET AUSE = FINDPREFUSE.F(START(ANODE), 0)
		IF AUSE NE 0
			AMODE = USEMODE(AUSE)
		ELSE
			LET ALCL = F.LCLDEFS(CURRPROC)
			WHILE ALCL NE 0
			DO
				IF LDEFNAME(ALCL) EQ LEXEME(START(ANODE))
					LEAVE
				ENDIF
				ALCL = S.LCLDEFS(ALCL)
			LOOP
			IF ALCL EQ 0
				CALL EASERR(1002, LEXEME(START(ANODE)))
			ENDIF
			AMODE = FINDMODE.F(LDEFTYPE(ALCL))
		ENDIF
			LET NODEPTRS(1) = F.SUBNODES(ANODE)
		IF AMODE = .MODE.INT	'' free-form read ints
			CALL SCRIPT(40)
		ENDIF
		IF AMODE = .MODE.TXT	'' free-form read text
			CALL SCRIPT(70)
		ENDIF
		IF AMODE = .MODE.NMBR
			CALL SCRIPT(75)
		ENDIF
		LET ANODE = S.NODES(ANODE)
	LOOP
	IF HASUSING NE 0
		CALL SCRIPT(62)
	ENDIF
	RETURN
ENDIF
IF MATCHNUM(ANODE) = 2
	LET ANODE = F.SUBNODES(ANODE)
	LET EXPNODE = F.SUBNODES(ANODE)
	LET FMTNODE = S.NODES(ANODE)
ELSE
	LET FMTNODE = F.SUBNODES(ANODE)
ENDIF
LET FMTNODE = F.SUBNODES(FMTNODE)
WHILE FMTNODE NE 0
DO
	LET ANODE = F.SUBNODES(FMTNODE)
	IF MATCHNUM(ANODE) = 1		'' a control format
		LET ANODE = F.SUBNODES(ANODE)
		LET MATCH = MATCHNUM(ANODE)
		IF MATCH = 1
			LET SCRIPTNUM = 21
			LET NODEPTRS(1) = F.SUBNODES(ANODE)
		ENDIF
		IF MATCH = 2
			LET SCRIPTNUM = 22
		ENDIF
		IF MATCH = 3
			LET SCRIPTNUM = 23
			LET NODEPTRS(1) = F.SUBNODES(ANODE)
		ENDIF
		IF MATCH = 4
			LET SCRIPTNUM = 24
			LET NODEPTRS(1) = ANODE
		ENDIF
	ELSE
		LET NODEPTRS(1) = F.SUBNODES(EXPNODE)
		LET ANODE = F.SUBNODES(F.SUBNODES((FMTNODE)))
		IF MATCHNUM(ANODE) = 1
			LET SCRIPTNUM = 37
			LET NODEPTRS(2) = F.SUBNODES(ANODE)
		ENDIF
		IF MATCHNUM(ANODE) = 2
			LET ANODE = F.SUBNODES(ANODE)
			IF MATCHNUM(ANODE) = 1
				LET SCRIPTNUM = 38
				LET NODEPTRS(2) = F.SUBNODES(ANODE)
			ELSE
				LET SCRIPTNUM = 24
			ENDIF
		ENDIF
		IF MATCHNUM(ANODE) = 3
			LET SCRIPTNUM = 69	'' RDP
		ENDIF
		IF MATCHNUM(ANODE) = 4	'' D FORMAT
			LET NODEPTRS(2) = F.SUBNODES(ANODE)
			LET NODEPTRS(3) = S.NODES(F.SUBNODES(ANODE))
			LET SCRIPTNUM = 71
		ENDIF
		LET EXPNODE = S.NODES(EXPNODE)
	ENDIF
	LET FMTNODE = S.NODES(FMTNODE)
	CALL SCRIPT(SCRIPTNUM)
LOOP
IF HASUSING NE 0
	CALL SCRIPT(62)
ENDIF
RETURN
Routine SCRIPTWRITE ASTMT ANODE EXPNODE FMTNODE SCRIPTNUM MATCH HASUSING
LET ANODE = F.PARSENODES(ASTMT)
IF S.NODES(ANODE) NE 0		'' using clause
	LET HASUSING = 1
	CALL SCRIPT(63)
	LET IPTRS(1) = 2
	CALL SCRIPT(60)
ENDIF
IF MATCHNUM(ANODE) = 2
	LET ANODE = F.SUBNODES(ANODE)
	LET EXPNODE = F.SUBNODES(ANODE)
	LET FMTNODE = F.SUBNODES(S.NODES(ANODE))
ELSE
	LET FMTNODE = F.SUBNODES(F.SUBNODES(ANODE))
ENDIF
WHILE FMTNODE NE 0
DO
	LET ANODE = F.SUBNODES(FMTNODE)
	IF MATCHNUM(ANODE) = 1		'' a control format
		LET ANODE = F.SUBNODES(ANODE)
		LET MATCH = MATCHNUM(ANODE)
		IF MATCH = 1
			LET SCRIPTNUM = 15
			LET NODEPTRS(1) = F.SUBNODES(ANODE)
		ENDIF
		IF MATCH = 2
			LET SCRIPTNUM = 16
		ENDIF
		IF MATCH = 3
			LET SCRIPTNUM = 17
			LET NODEPTRS(1) = F.SUBNODES(ANODE)
		ENDIF
		IF MATCH = 4
			LET SCRIPTNUM = 9
			LET NODEPTRS(1) = ANODE
		ENDIF
	ELSE
		LET NODEPTRS(1) = F.SUBNODES(EXPNODE)
		LET ANODE = F.SUBNODES(F.SUBNODES((FMTNODE)))
		IF MATCHNUM(ANODE) = 1
			LET SCRIPTNUM = 10
			LET NODEPTRS(2) = F.SUBNODES(ANODE)
		ENDIF
		IF MATCHNUM(ANODE) = 2
			LET ANODE = F.SUBNODES(ANODE)
			IF MATCHNUM(ANODE) = 1
				LET SCRIPTNUM = 19
				LET NODEPTRS(2) = F.SUBNODES(ANODE)
			ELSE
				LET SCRIPTNUM = 9
			ENDIF
		ENDIF
		IF MATCHNUM(ANODE) = 3
			LET SCRIPTNUM = 68	'' WTP
		ENDIF
		IF MATCHNUM(ANODE) = 4	'' D FORMAT
			LET NODEPTRS(2) = F.SUBNODES(ANODE)
			LET NODEPTRS(3) = S.NODES(F.SUBNODES(ANODE))
			LET SCRIPTNUM = 74
		ENDIF
		LET EXPNODE = S.NODES(EXPNODE)
	ENDIF
	LET FMTNODE = S.NODES(FMTNODE)
	CALL SCRIPT(SCRIPTNUM)
LOOP
IF HASUSING NE 0
	CALL SCRIPT(64)
ENDIF
RETURN
Routine STMTSCRIPT ASTMT ANODE PSTMT I SCRIPTNO AUSE PRTLINE ALCL
LET SCRIPTLEVEL = SCRIPTDEPTH(ASTMT) + 1
FOR I = 1 TO 9
DO
	LET NODEPTRS(I) = 0
LOOP
LET ANODE = F.PARSENODES(ASTMT)
CALL SETNODEPTRS(ANODE)
IF RULENAME(STMTRULE(ASTMT)) EQ "FOR"
	LET LBL = LBL + 1
	LET LBLNUM(ASTMT) = LBL
	
	IF LASTCTLSTMT NE 0
		LET P.CTRLSTMT(ASTMT) = LASTCTLSTMT
	ENDIF
	LET LASTCTLSTMT = ASTMT
	
	LET STRPTRS(2) = SCRIPTLBL("next", LBL)
	IF P.CTRLSTMT(ASTMT) = 0
		LET STRPTRS(3) = SCRIPTLBL("done", LBL)
	ELSE
		LET STRPTRS(3) = SCRIPTLBL("next", LBLNUM(P.CTRLSTMT(ASTMT)))
	ENDIF
	LET STRPTRS(6) = SCRIPTLBL("test", LBL)
	IF MATCHNUM(ANODE) = 1
		LET LV = LV + 1
		LET STRPTRS(4) = SCRIPTLBL("E_", LV)
		LET AUSE = FINDPREFUSE.F(START(NODEPTRS(1)), 0)
		IF AUSE NE 0
			LET STRPTRS(5) = ETYPENAME(USEENTITY(AUSE))
		ELSE
			LET ALCL = F.LCLDEFS(CURRPROC)
			WHILE ALCL NE 0
			DO
				IF LDEFNAME(ALCL) EQ LEXEME(START(NODEPTRS(1)))
					LEAVE
				ENDIF
				ALCL = S.LCLDEFS(ALCL)
			LOOP
			IF ALCL EQ 0
				CALL EASERR(1002, LEXEME(START(NODEPTRS(1))))
			ENDIF
			LET STRPTRS(5) = ETYPENAME(LDEFTYPE(ALCL))
		ENDIF
		CALL SCRIPT(41)
		LET SCRIPTNO = 2
	ELSE
		LET SCRIPTNO = 3
	ENDIF
	CALL SCRIPT(SCRIPTNO)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "WHILE"
	LET I = 0
	LET PSTMT = LASTCTLSTMT
	WHILE PSTMT NE 0
	DO
		LET I = LBLNUM(PSTMT)
		LET PSTMT = P.CTRLSTMT(PSTMT)
	LOOP
	IF I EQ 0					'' stand-alone WHILE
		LET LASTCTLSTMT = ASTMT
		LET LBL = LBL + 1
		LET LBLNUM(ASTMT) = LBL
		LET STRPTRS(1) = SCRIPTLBL("next", LBL)
		CALL SCRIPT(7)
		LET STRPTRS(3) = SCRIPTLBL("done", LBL)
	ELSE
		LET LBLNUM(ASTMT) = I
		LET STRPTRS(3) = SCRIPTLBL("done", I)
	ENDIF
	CALL SCRIPT(8)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "UNTIL"
	IF LASTCTLSTMT = 0
		CALL EASERR(1004, 0)
		RETURN
	ENDIF
	LET PSTMT = LASTCTLSTMT
	WHILE P.CTRLSTMT(PSTMT) NE 0
	DO
		LET PSTMT = P.CTRLSTMT(PSTMT)
	LOOP
	LET STRPTRS(3) = SCRIPTLBL("done", LBLNUM(PSTMT))
	CALL SCRIPT(14)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "WITH"
	IF LASTCTLSTMT = 0
		CALL EASERR(1005, 0)
		RETURN
	ENDIF
	LET STRPTRS(3) = SCRIPTLBL("next", LBLNUM(LASTCTLSTMT))
	CALL SCRIPT(8)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "FIND"
	IF LASTCTLSTMT EQ 0
		CALL EASERR(1006, 0)
		RETURN
	ENDIF
	IF MATCHNUM(ANODE) = 1
		LET NODEPTRS(1) = F_SUBNODES(ANODE)
		LET NODEPTRS(2) = S_NODES(NODEPTRS(1))
		CALL SCRIPT(4) '' assign found value - just one, for now
	ENDIF
	LET PSTMT = LASTCTLSTMT
	LET LASTCTLSTMT = 0
	WHILE PSTMT NE 0
	DO
		LET I = LBLNUM(PSTMT)
		LET PSTMT = P_CTRLSTMT(PSTMT)
	LOOP
	LET STRPTRS(1) = SCRIPTLBL("skip", I)
	LET STRPTRS(2) = SCRIPTLBL("done", I)
	CALL SCRIPT(53)
	IF S_NODES(ANODE) NE 0
		IF MATCHNUM(S.NODES(ANODE)) EQ 1
			CALL SCRIPT(54)
		ELSE
			CALL SCRIPT(55)
		ENDIF
	ENDIF
	RETURN	
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "DO"
	IF LASTCTLSTMT = 0
		CALL EASERR(1007, 0)
		RETURN
	ENDIF
	LET P_CTRLSTMT(ASTMT) = LASTCTLSTMT
	IF LASTDOSTMT NE 0
		LET P_DOSTMT(ASTMT) = LASTDOSTMT
	ENDIF
	LET LASTDOSTMT = ASTMT
	LET LASTCTLSTMT = 0
	LET CURRLOOPDEPTH = CURRLOOPDEPTH + 1
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "LOOP"
	IF LASTDOSTMT = 0
		CALL EASERR(1008, 0)
		RETURN
	ENDIF
	LET CURRLOOPDEPTH = CURRLOOPDEPTH - 1
	LET PSTMT = P_CTRLSTMT(LASTDOSTMT)
	LET STRPTRS(2) = SCRIPTLBL("next", LBLNUM(PSTMT))
	WHILE P_CTRLSTMT(PSTMT) NE 0
	DO
		LET PSTMT = P_CTRLSTMT(PSTMT)
	LOOP
	LET STRPTRS(3) = SCRIPTLBL("done", LBLNUM(PSTMT))
	CALL SCRIPT(13)
	LET LASTDOSTMT = P.DOSTMT(LASTDOSTMT)
	RETURN
ENDIF
	
IF RULENAME(STMTRULE(ASTMT)) EQ "LEAVE"
	IF LASTDOSTMT = 0
		CALL EASERR(1009, 0)
		RETURN
	ENDIF
	LET PSTMT = P_CTRLSTMT(LASTDOSTMT)
	IF P_CTRLSTMT(PSTMT) = 0
		LET STRPTRS(3) = SCRIPTLBL("done", LBLNUM(PSTMT))
	ELSE
		LET STRPTRS(3) = SCRIPTLBL("next", LBLNUM(P_CTRLSTMT(PSTMT)))
	ENDIF
	CALL SCRIPT(18)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "CYCLE"
	IF LASTDOSTMT = 0
		CALL EASERR(1009, 0)
		RETURN
	ENDIF
	LET PSTMT = P_CTRLSTMT(LASTDOSTMT)
	LET STRPTRS(3) = SCRIPTLBL("next", LBLNUM(PSTMT))
	CALL SCRIPT(18)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "FILE"
	LET ANODE = S.NODES(F.PARSENODES(ASTMT))
	LET I = 0
	IF SCRIPTCODE(ANODE) = 0		'' explicit first/last
		LET I = MATCHNUM(ANODE)
		LET ANODE = S_NODES(ANODE)	
	ENDIF
	LET AUSE = FINDSPECUSE_F(DICTREF(START(ANODE)), .USE.ATTR)
	IF AUSE EQ 0
		CALL EASERR(1010, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	IF ISSETTYPE(USEENTITY(AUSE)) EQ 0
		CALL EASERR(1010, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	IF SETDISCIPLINE(SETATTRSETDEF(USESETREFATT(AUSE))) EQ 0	'' ranked
		IF I NE 0	'' first or last specified?
			CALL EASERR(1016, LEXEME(START(ANODE)))
			RETURN
		ENDIF
		LET STRPTRS(1) = LEXEME(START(F.SUBNODES(NODEPTRS(2))))
		IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
			LET SCRIPTNO = 57
		ELSE
			LET SCRIPTNO = 42
		ENDIF
	ELSE
		LET SCRIPTNO = 6	'' presume default LIFO
		IF I EQ 0
			IF SETDISCIPLINE(SETATTRSETDEF(USESETREFATT(AUSE))) EQ 1	'' FIFO
				LET SCRIPTNO = 5
			ENDIF
		ELSE
			IF I EQ 1
				LET SCRIPTNO = 5
			ENDIF
		ENDIF
		IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
			LET SCRIPTNO = SCRIPTNO + 43
		ENDIF
	ENDIF
	IF SCRIPTNO NE 0
		CALL SCRIPT(SCRIPTNO)
	ENDIF
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "REMOV"
	LET ANODE = F.PARSENODES(ASTMT)
	LET SCRIPTNO = 0
	IF SCRIPTCODE(ANODE) = 0		'' explicit first/last
		LET SCRIPTNO = 34
		IF MATCHNUM(ANODE) = 2
			LET SCRIPTNO = 35
		ENDIF
		IF MATCHNUM(ANODE) = 3		'' SPECIFIC
			LET SCRIPTNO = 36
		ENDIF
		LET ANODE = S.NODES(ANODE)
	ENDIF
	LET AUSE = FINDSPECUSE_F(DICTREF(START(ANODE)), .USE.ATTR)
	IF AUSE EQ 0
		CALL EASERR(1010, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	IF ISSETTYPE(USEENTITY(AUSE)) EQ 0
		CALL EASERR(1010, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	IF SCRIPTNO = 0
		LET SCRIPTNO = 34
		IF SETDISCIPLINE(SETATTRSETDEF(USESETREFATT(AUSE))) EQ 1	'' FIFO
			LET SCRIPTNO = 35
		ENDIF
	ENDIF
	IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
		LET SCRIPTNO = SCRIPTNO + 16
	ENDIF
	CALL SCRIPT(SCRIPTNO)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "OPEN"
	IF MATCHNUM(S.NODES(ANODE)) EQ 1
		LET SCRIPTNO = 11
	ELSE
		LET SCRIPTNO = 12
	ENDIF
	CALL SCRIPT(SCRIPTNO)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "CLOSE"
	CALL SCRIPT(20)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "WRITE"
	CALL SCRIPTWRITE(ASTMT)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "READ"
	CALL SCRIPTREAD(ASTMT)
	RETURN
ENDIF
		
IF RULENAME(STMTRULE(ASTMT)) EQ "USE"
	LET IPTRS(1) = MATCHNUM(S.NODES(ANODE))	'' input/output
	CALL SCRIPT(60)
	RETURN
ENDIF
		
IF RULENAME(STMTRULE(ASTMT)) EQ "RESERVE"
	IF S.NODES(S.NODES(ANODE)) NE 0		'' a 'by' expression
		LET END(ANODE) = START(ANODE) 	'' 'isolate' the array name
		LET ANODE = S.NODES(ANODE)		'' first exp
		LET NODEPTRS(2) = ANODE
		LET LV = LV + 1
		LET STRPTRS(1) = SCRIPTLBL("I_", LV)
		CALL SCRIPT(25)
		
		LET NODEPTRS(3) = S.NODES(ANODE)	'' by exp
		LET LV = LV + 1
		LET STRPTRS(2) = SCRIPTLBL("I_", LV)
		LET LV = LV + 1
		LET STRPTRS(3) = SCRIPTLBL("I_", LV)
		CALL SCRIPT(26)
	ENDIF
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "PRINTN"
	LET PRTLINE = F.FMTLINES(ASTMT)
	WHILE PRTLINE NE 0
	DO
		LET STRPTRS(1) = LTXT(PRTLINE)
		CALL SCRIPT(39)
		LET PRTLINE = S.SRCLINES(PRTLINE)
	LOOP
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "ERASE"
	CALL SCRIPT(27)
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "PSERVER"
	IF MATCHNUM(ANODE) = 1
		CALL SCRIPT(65)
	ELSE
		CALL SCRIPT(66)
	ENDIF
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "RECUNL"
	IF MATCHNUM(ANODE) = 1
		CALL SCRIPT(58)
	ENDIF
	RETURN
ENDIF
IF RULENAME(STMTRULE(ASTMT)) EQ "IF"
	IF MATCHNUM(ANODE) = 2				'' IS A ....
		LET STRPTRS(2) = LEXEME(DICTREF(END(ANODE)))
		CALL SCRIPT(67)
	ENDIF
	RETURN
ENDIF
RETURN END
Routine SCRIPTLOOP I J PSTMT
IF LASTCTLSTMT EQ 0
	CALL EASERR(1007, 0)
ELSE
	'' script single statement loop here
	LET PSTMT = LASTCTLSTMT
	LET LASTCTLSTMT = 0
	WHILE PSTMT NE 0
	DO
		IF RULENAME(STMTRULE(PSTMT)) EQ "FOR"
		 OR RULENAME(STMTRULE(PSTMT)) EQ "WHILE"
		  OR RULENAME(STMTRULE(PSTMT)) EQ "UNTIL"
			LET STRPTRS(2) = SCRIPTLBL("next", LBLNUM(PSTMT))
			LET STRPTRS(3) = SCRIPTLBL("done", LBLNUM(PSTMT))
			CALL SCRIPT(13)
		ENDIF
		LET PSTMT = P.CTRLSTMT(PSTMT)
	LOOP
ENDIF
RETURN
Function SCRIPTLBL RET PREFIX NUM I J ALBL
LET ALBL = CONCAT.F(PREFIX, "0000")
LET I = LENGTH.F(PREFIX)
LET J = I + 4
WHILE NUM > 9
DO
	I = NUM
	NUM = NUM / 10
	I = I - NUM * 10
	LET ACHAR.F(ALBL, J) = I + 48
	J = J - 1
LOOP
LET ACHAR.F(ALBL, J) = NUM + 48
RETURN WITH ALBL
Routine SETNODEPTRS ANODE
WHILE ANODE NE 0
DO
	IF SCRIPTCODE(ANODE) NE 0
		LET NODEPTRS(SCRIPTCODE(ANODE)) = ANODE
	ENDIF
	IF F.SUBNODES(ANODE) NE 0
		CALL SETNODEPTRS(F.SUBNODES(ANODE))
	ENDIF
	LET ANODE = S.NODES(ANODE)
LOOP
RETURN
Routine SCRIPT SCRIPTNO AELEM ANODE ATOKEN TKN TMPTXT I
LET AELEM = SCRIPTS(SCRIPTNO)
IF AELEM EQ 0
	RETURN
ENDIF
''write "scripting:" as t *
''write as /
WHILE AELEM NE 0
DO	
	IF SCRIPTCODE(AELEM) EQ 0
		CREATE A TOKEN CALLED ATOKEN
		LET SCRIPTED(ATOKEN) = SCRIPTLEVEL
		LET DICTREF(ATOKEN) = DICTREF(AELEM)
		LET LEXEME(ATOKEN) = LEXEME(DICTREF(AELEM))
''		write lexeme(atoken) as t *  write as s 2
		LET TOKENTYPE(ATOKEN) = TKNFORM(AELEM)
		CALL FILETOKEN(ATOKEN)
	ELSE
		IF SCRIPTACTION(AELEM) EQ 1
			LET ANODE = NODEPTRS(SCRIPTCODE(AELEM))
			IF ANODE NE 0
				LET TKN = START(ANODE)
				WHILE TKN NE S.TOKENLIST(END(ANODE))
				DO
					CREATE A TOKEN CALLED ATOKEN
					LET SCRIPTED(ATOKEN) = SCRIPTLEVEL
					LET DICTREF(ATOKEN) = DICTREF(TKN)
					LET LEXEME(ATOKEN) = LEXEME(DICTREF(TKN))
''		write lexeme(atoken) as t *  write as s 2
					LET TOKENTYPE(ATOKEN) = TOKENTYPE(TKN)
					CALL FILETOKEN(ATOKEN)
					LET TKN = S.TOKENLIST(TKN)
				LOOP
			ENDIF
		ENDIF
		IF SCRIPTACTION(AELEM) EQ 2
			CREATE A TOKEN CALLED ATOKEN
			LET SCRIPTED(ATOKEN) = SCRIPTLEVEL
			LET LEXEME(ATOKEN) = STRPTRS(SCRIPTCODE(AELEM))
''		write lexeme(atoken) as t *  write as s 2
			LET TOKENTYPE(ATOKEN) = TKNFORM(AELEM)
			LET DICTREF(ATOKEN) = FINDDICTENTRY_F(LEXEME(ATOKEN))
			CALL FILETOKEN(ATOKEN)
		ENDIF
		IF SCRIPTACTION(AELEM) EQ 3
			CREATE A TOKEN CALLED ATOKEN
			LET SCRIPTED(ATOKEN) = SCRIPTLEVEL
			LET TMPTXT = "__"
			LET ACHAR.F(TMPTXT, 1) = SCRIPTPREFIX(AELEM)
			LET LEXEME(ATOKEN) = CONCAT.F(TMPTXT, STRPTRS(SCRIPTCODE(AELEM)))
''		write lexeme(atoken) as t *  write as s 2
			LET TOKENTYPE(ATOKEN) = TKNFORM(AELEM)
			LET DICTREF(ATOKEN) = FINDDICTENTRY_F(LEXEME(ATOKEN))
			CALL FILETOKEN(ATOKEN)
		ENDIF
		IF SCRIPTACTION(AELEM) EQ 4
			LET ANODE = NODEPTRS(SCRIPTCODE(AELEM))
			CREATE A TOKEN CALLED ATOKEN
			LET SCRIPTED(ATOKEN) = SCRIPTLEVEL
			LET TMPTXT = "__"
			LET ACHAR.F(TMPTXT, 1) = SCRIPTPREFIX(AELEM)
			LET LEXEME(ATOKEN) = CONCAT.F(TMPTXT, LEXEME(START(ANODE)))
''		write lexeme(atoken) as t *  write as s 2
			LET TOKENTYPE(ATOKEN) = TKNFORM(AELEM)
			LET DICTREF(ATOKEN) = FINDDICTENTRY_F(LEXEME(ATOKEN))
			CALL FILETOKEN(ATOKEN)
		ENDIF
		IF SCRIPTACTION(AELEM) EQ 5
			CREATE A TOKEN CALLED ATOKEN
			LET SCRIPTED(ATOKEN) = SCRIPTLEVEL
			LET LEXEME(ATOKEN) = ITOT_F(IPTRS(SCRIPTCODE(AELEM)))
''		write lexeme(atoken) as t *, s 2
			LET TOKENTYPE(ATOKEN) = TKNFORM(AELEM)
			LET DICTREF(ATOKEN) = FINDDICTENTRY_F(LEXEME(ATOKEN))
			CALL FILETOKEN(ATOKEN)
		ENDIF
	ENDIF
	LET AELEM = S.SCRIPTELEMS(AELEM)
LOOP
'' write as /
RETURN	
Routine READSCRIPT SCRIPTNO ATOKEN AELEM LASTELEM LAST CLEAN
LET ATOKEN = F.TOKENLIST
WHILE LEXEME(ATOKEN) NE "!"
DO
	CREATE A SCRIPTELEM CALLED AELEM
	IF LEXEME(ATOKEN) = "#"
		LET ATOKEN = S.TOKENLIST(ATOKEN)
		LET SCRIPTACTION(AELEM) = 1
		LET SCRIPTCODE(AELEM) = ACHAR.F(LEXEME(ATOKEN), 1) - 48
		IF LEXEME(DICTREF(S.TOKENLIST(ATOKEN))) = "|"
			LET ATOKEN = S.TOKENLIST(ATOKEN)
		ENDIF
	ENDIF
	IF LEXEME(ATOKEN) = "%"
		LET ATOKEN = S.TOKENLIST(ATOKEN)
		LET TKNFORM(AELEM) = .TKN.IDENT
		IF LEXEME(ATOKEN) = "%"
			LET TKNFORM(AELEM) = .TKN.NMBR
			LET ATOKEN = S.TOKENLIST(ATOKEN)
		ENDIF
		IF LEXEME(ATOKEN) = "^"
			LET TKNFORM(AELEM) = .TKN.QSTR
			LET ATOKEN = S.TOKENLIST(ATOKEN)
		ENDIF
		LET SCRIPTACTION(AELEM) = 2
		LET SCRIPTCODE(AELEM) = ACHAR.F(LEXEME(ATOKEN), 1) - 48
	ENDIF
	
	IF LEXEME(ATOKEN) = "@"
		LET ATOKEN = S.TOKENLIST(ATOKEN)
		LET SCRIPTPREFIX(AELEM) = ACHAR.F(LEXEME(ATOKEN), 1)
		LET ATOKEN = S.TOKENLIST(ATOKEN)
		LET SCRIPTACTION(AELEM) = 3
		IF LEXEME(ATOKEN) = "#"
			LET SCRIPTACTION(AELEM) = 4
		ENDIF
		LET ATOKEN = S.TOKENLIST(ATOKEN)
		LET TKNFORM(AELEM) = 3	
		LET SCRIPTCODE(AELEM) = ACHAR.F(LEXEME(ATOKEN), 1) - 48
	ENDIF
	IF LEXEME(ATOKEN) ="~"
		LET ATOKEN = S.TOKENLIST(ATOKEN)
		LET TKNFORM(AELEM) = 2	
		LET SCRIPTCODE(AELEM) = ACHAR.F(LEXEME(ATOKEN), 1) - 48
		LET SCRIPTACTION(AELEM) = 5
	ENDIF
	IF SCRIPTCODE(AELEM) = 0	'' none of the above
		LET DICTREF(AELEM) = DICTREF(ATOKEN)
		LET TKNFORM(AELEM) = TOKENTYPE(ATOKEN)
	ENDIF
	
	IF SCRIPTS(SCRIPTNO) = 0
		LET SCRIPTS(SCRIPTNO) = AELEM
	ELSE
		LET S.SCRIPTELEMS(LASTELEM) = AELEM
	ENDIF
	LET LASTELEM = AELEM
	LET ATOKEN = S.TOKENLIST(ATOKEN)
LOOP
LET ATOKEN = S.TOKENLIST(ATOKEN)
LET LAST = F.TOKENLIST
LET F.TOKENLIST = ATOKEN
WHILE LAST NE F.TOKENLIST
DO
	LET CLEAN = LAST
	LET LAST = S.TOKENLIST(LAST)
	LET LEXEME(CLEAN) = ""
	DESTROY TOKEN CALLED CLEAN
LOOP
RETURN
Routine READSCRIPTS FILENAME SCRIPTNO ALINE LEN
RESERVE SCRIPTS AS 128
SCRIPTNO = 1
OPEN 5 FOR INPUT, NAME IS FILENAME
USE 5 FOR INPUT
LET EOF.V = 1
WHILE EOF.V NE 2
DO
	READ ALINE AS T RRECLEN.V
	LET LEN = LENGTH.F(ALINE)
	CALL ANALYZE(ALINE, LEN, 1)
	CALL READSCRIPT(SCRIPTNO)
	LET SCRIPTNO = SCRIPTNO + 1
	READ AS /
LOOP
CLOSE 5
RESERVE NODEPTRS AS 9
RESERVE STRPTRS AS 9
RESERVE IPTRS AS 9
RETURN
Function GENPATTR M AUSE VARTOKEN SUBNODE ISPUT MODE SUSE AREF
IF ISPUT NE 0 
	IF USEMODE(AUSE) = .MODE.REF AND ISPERSISTENT(USEENTITY(AUSE)) NE 0
		WRITE AS "easg((char*)&"
	ENDIF
	WRITE AS "(*"
	CALL GENSTARCAST(USEENTITY(AUSE))
	WRITE AS "&"
ELSE
	CALL GENCAST(USEENTITY(AUSE))
ENDIF
WRITE AS "("
CALL GENCAST(USEOWNER(AUSE))
WRITE AS "fetch((iRef*)"
IF SUBNODE NE 0 AND USESUBS(AUSE) = 0
	LET MODE = GENEXP(SUBNODE)
	LET SUBNODE = 0
ELSE				'' implicit subscript
	AREF = FINDDICTENTRY.F(ETYPENAME(USEOWNER(AUSE)))
	IF FINDSPECUSE.F(AREF, .USE.LCL) EQ 0
		SUSE = FINDSPECUSE.F(AREF, .USE.ATTR)	'' of 'system'
		IF SUSE EQ 0
			CALL EASERR(1018, LEXEME(AREF))
		ELSE
			WRITE ETYPENAME(USEOWNER(SUSE)) AS T *, "->"
		ENDIF
	ENDIF
	WRITE LEXEME(AREF) AS T *					'' owning entity name
ENDIF
WRITE LEXEME(DICTREF(VARTOKEN)) AS "))->", T *	'' attribute name
IF SUBNODE NE 0
	LET MODE = GENEXP(SUBNODE)
ENDIF
IF ISPUT NE 0
	WRITE AS ")"
ENDIF
RETURN WITH USEMODE(AUSE)
END
Function GENPENTREF M AUSE VARTOKEN SUBNODE ISPUT MODE
IF ISPUT NE 0
	WRITE AS "easg((char*)&"
ELSE
	CALL GENCAST(USEENTITY(AUSE))
ENDIF
IF SUBNODE NE 0 AND USESUBS(AUSE) = 0
	LET MODE = GENEXP(SUBNODE)
	LET SUBNODE = 0
ELSE
	WRITE ETYPENAME(USEOWNER(AUSE)) AS T *
ENDIF
WRITE LEXEME(DICTREF(VARTOKEN)) AS "->", T *
IF SUBNODE NE 0
	LET MODE = GENEXP(SUBNODE)
ENDIF
RETURN WITH .MODE.REF
END
Routine GENSTARCAST ETYPE
WRITE AS "("
IF TARGETNAME(ETYPE) NE ""
	WRITE TARGETNAME(ETYPE) AS T *
ELSE
	WRITE ETYPENAME(ETYPE) AS T *
ENDIF
WRITE AS "*)"
RETURN
END
Routine GENCAST ETYPE
WRITE AS "("
IF TARGETNAME(ETYPE) NE ""
	WRITE TARGETNAME(ETYPE) AS T *
ELSE
	WRITE ETYPENAME(ETYPE) AS "struct ", T *, "*"
ENDIF
WRITE AS ")"
RETURN
END
Function QUOTE_F T TXT L
LET TXT = CONCAT.F(" ", TXT)
LET TXT = CONCAT.F(TXT, " ")
LET ACHAR.F(TXT, 1) = 34
LET L = LENGTH.F(TXT)
LET ACHAR.F(TXT, L) = 34
RETURN WITH TXT
END
Routine GENHEADER ASCHEMA ISCHEMA TXT ETYPE SYSENT ATT
'' generate header file
PRINT 1 LINE THUS
#pragma once\n\#include \"easlib.h\"\n
LET ISCHEMA = F.SCHEMAS
WHILE ISCHEMA NE 0
DO
	IF ISCHEMA NE ASCHEMA AND NOGEN(ISCHEMA) EQ 0
		LET TXT = CONCAT.F(GENNAME(ISCHEMA), ".h")
		WRITE QUOTE.F(TXT) AS "#include ", T *, /
	ENDIF
	LET ISCHEMA = S.SCHEMAS(ISCHEMA)
LOOP
WRITE AS /
	LET ETYPE = F.ETYPES(ASCHEMA)
	WHILE ETYPE NE 0
	DO
		IF ISPROC(ETYPE) = 0
''			IF ISUSEDTYPE(ETYPE) NE 0
				WRITE ETYPENAME(ETYPE) AS "#define _", T *, /
''			ENDIF
		ENDIF
		LET ETYPE = S.ETYPES(ETYPE)
	LOOP
WRITE AS /
'' entity structs
LET ETYPE = F.ETYPES(ASCHEMA)
WHILE ETYPE NE 0
DO
	IF ISPROC(ETYPE) = 0
		WRITE ETYPENAME(ETYPE) AS "struct ", T *, " {", /
		IF NOHDR(ASCHEMA) = 0
			WRITE AS "struct eInstHdr hdr;", /
		ENDIF
		LET ATT = F.ATTRDEFS(ETYPE)
		WHILE ATT NE 0
		DO
			WRITE MAKEATTRTYPE.F(ATT), ATTRNAME(ATT) AS T *, S 1, T *, ";", /
			LET ATT = S.ATTRDEFS(ATT)
		LOOP
		WRITE AS "};", /
		WRITE ETYPENAME(ETYPE), ETYPENAME(ETYPE) AS 
			"#define Z_", T *, " sizeof(", T *, ")", /
		IF ISPERSISTENT(ETYPE) NE 0
			CALL GENMAP(ETYPE)
		ENDIF
	ENDIF
	LET ETYPE = S.ETYPES(ETYPE)
LOOP
'' procedure prototypes
LET ETYPE = F.ETYPES(ASCHEMA)
WHILE ETYPE NE 0
DO
	IF ISPROC(ETYPE) NE 0
		IF ETYPENAME(ETYPE) NE "MAIN"
			LET ATT = F.ATTRDEFS(ETYPE)
			WHILE ATT NE 0
			DO
				IF ISRETTYPE(ATT) NE 0
					LEAVE
				ENDIF
				LET ATT = S.ATTRDEFS(ATT)
			LOOP
			IF ATT NE 0
				WRITE MAKEATTRTYPE_F(ATT) AS T *
			ELSE
				WRITE AS "void"
			ENDIF
			WRITE ETYPENAME(ETYPE) AS S 1, T *
			CALL GENARGLIST(ETYPE)
			WRITE AS ";", /
		ENDIF
	ENDIF
	LET ETYPE = S.ETYPES(ETYPE)
LOOP
LET ETYPE = THESYSTEM(ASCHEMA)
IF ETYPE NE 0			'' and write its struct
	WRITE ETYPENAME(ETYPE) AS /, "struct ", T *, "_sys {", /
	WRITE AS "struct eInstHdr hdr;", /
	LET ATT = F.ATTRDEFS(ETYPE)
	WHILE ATT NE 0
	DO
		WRITE MAKEATTRTYPE.F(ATT), ATTRNAME(ATT) AS T *, S 1, T *, ";", /
		LET ATT = S.ATTRDEFS(ATT)
	LOOP
	WRITE AS "};", /
	WRITE GENNAME(ASCHEMA), GENNAME(ASCHEMA) AS "extern ", T *, "_sys* ", T *, ";", /
ENDIF
WRITE GENNAME(ASCHEMA) AS "void ", T *, "_init();", /
RETURN END
Routine GENCOMP ANODE FINDER AUSE MODE1 MODE2 OPMATCH
LET OPMATCH = MATCHNUM(S.NODES(ANODE))
LET FINDER = F.SUBNODES(ANODE)
WHILE F.SUBNODES(FINDER) NE 0
 LET FINDER = F.SUBNODES(FINDER)	'' looking for first term of expression
LET AUSE = FINDPREFUSE.F(START(FINDER), 1)
IF USEMODE(AUSE) EQ .MODE.TXT
	IF OPMATCH EQ 1
		WRITE AS "E_TXTEQL_F("
	ELSE
		WRITE AS "E_TXTNEQ_F("
	ENDIF
	LET MODE1 = GENEXP(ANODE)
	WRITE AS ", "
	LET MODE2 = GENEXP(S.NODES(S.NODES(ANODE)))
	WRITE AS ")"
	'' check modes ?
	RETURN
ENDIF
LET MODE1 = GENEXP(ANODE)
LET ANODE = S.NODES(ANODE)
WRITE LOGICOPS(OPMATCH) AS T *
LET ANODE = S.NODES(ANODE)
LET MODE2 = GENEXP(ANODE)
'' check modes ?
RETURN END
Routine GENLOGICL ANODE SUBNODE
LET SUBNODE = F.SUBNODES(ANODE)
IF S.NODES(SUBNODE) NE 0			'' true/false ?
	IF MATCHNUM(F.SUBNODES(S.NODES(SUBNODE))) = 2
		WRITE AS " ! "
	ENDIF
ENDIF
IF MATCHNUM(SUBNODE) EQ 1			'' parens
	WRITE AS " ( "
	CALL GENLOGICL(S.NODES(F.SUBNODES(SUBNODE)))
	WRITE AS " ) "
ELSE
	CALL GENCOMP(F.SUBNODES(SUBNODE))
ENDIF
LET ANODE = S.NODES(ANODE)			'' more ?
IF ANODE NE 0
	LET SUBNODE = F.SUBNODES(ANODE)
	IF MATCHNUM(SUBNODE) EQ 1
		WRITE AS " & "
	ELSE
		WRITE AS " | "
	ENDIF
	LET ANODE = S.NODES(SUBNODE)	'' skip operator
	CALL GENLOGICL(ANODE)
ENDIF
RETURN END
Routine GENARRSUBS ANODE EMODE
WHILE ANODE NE 0
DO
	IF MATCHNUM(ANODE) NE 1
		RETURN			'' STAR * don't gen
	ENDIF
	WRITE AS "["
	LET EMODE = GENEXP(ANODE)
	WRITE AS "]"
	LET ANODE = S.NODES(ANODE)
LOOP
RETURN END
Function GENPOWER M ANODE MODE EXPNODE SUBNODE MATCH
LET SUBNODE = F.SUBNODES(ANODE)		'' EXP1
LET EXPNODE = S.NODES(SUBNODE)	'' **
LET S.NODES(SUBNODE) = 0			'' isolate
WRITE AS " pow("
LET MODE = GENEXP(ANODE)			'' EXP
WRITE AS ", "
LET ANODE = S.NODES(F.SUBNODES(EXPNODE))	'' EXP
LET S.NODES(F.SUBNODES(ANODE)) = 0	'' isolate from any MOREXP
LET MODE = GENEXP(ANODE)
WRITE AS ")"
RETURN WITH MODE
END
Function GENEXP M ANODE MODE SUBNODE MATCH
LET SUBNODE = S.NODES(F.SUBNODES(ANODE))
IF SUBNODE NE 0							'' MOREXP
	LET SUBNODE = F.SUBNODES(SUBNODE)	'' operator
	IF MATCHNUM(SUBNODE) EQ 1			'' ** operator - special case!
		LET SUBNODE = S.NODES(F.SUBNODES(S.NODES(SUBNODE)))	'' MOREXP ?
		LET MODE = GENPOWER(ANODE)
		IF SUBNODE NE 0
			LET ANODE = F.SUBNODES(SUBNODE)
			WRITE LEXEME(DICTREF(START(ANODE))) AS T *	'' operator
			LET ANODE = S.NODES(ANODE)
			IF ANODE NE 0
				LET MODE = GENEXP(ANODE)
			ENDIF
		ENDIF
		RETURN WITH MODE
	ENDIF
ENDIF
LET ANODE = F.SUBNODES(ANODE)			'' EXP1
LET SUBNODE = F.SUBNODES(ANODE)
IF S.NODES(SUBNODE) EQ L.SUBNODES(ANODE)	'' unary sign ?
	IF MATCHNUM(SUBNODE) EQ 2
		WRITE LEXEME(DICTREF(START(SUBNODE))) AS T *
	ENDIF
	LET SUBNODE = S.NODES(SUBNODE)		'' skip to first term
ENDIF
LET MATCH = MATCHNUM(SUBNODE)
IF MATCH EQ 1
	WRITE LEXEME(DICTREF(START(SUBNODE))) AS T *
	LET MODE = .MODE.INT
ENDIF
IF MATCH EQ 2
	WRITE LEXEME(DICTREF(START(SUBNODE))) AS T *
	LET MODE = .MODE.NMBR
ENDIF
IF MATCH EQ 3
	WRITE QUOTE_F(LEXEME(DICTREF(START(SUBNODE)))) AS "E_TXTLIT_F(_T(", T *, "))"
	LET MODE = .MODE.TXT
ENDIF
IF MATCH EQ 4
	LET MODE = GENVAR(SUBNODE, 0)
ENDIF
IF MATCH EQ 5
	WRITE AS "("
	LET MODE = GENEXP(F.SUBNODES(SUBNODE))
	WRITE AS ")"
ENDIF
IF MATCH EQ 6
	WRITE LEXEME(DICTREF(START(F.SUBNODES(SUBNODE)))) AS T *
	LET MODE = .MODE.UNDEF		'' for now...
ENDIF
IF S.NODES(ANODE) NE 0							'' more sub-expressions?
	LET ANODE = F.SUBNODES(S.NODES(ANODE))
	WRITE LEXEME(DICTREF(START(ANODE))) AS T *	'' operator
	LET ANODE = S.NODES(ANODE)
	IF ANODE NE 0
		LET MODE = GENEXP(ANODE)
	ENDIF
ENDIF
RETURN WITH MODE
END
Function GENVAR M ANODE ISPUT MODE VARTOKEN SUBNODE AUSE SUSE DREF AREF EMODE ETYPE MREF SDEF ATT SAVP
LET VARTOKEN = START(ANODE)
IF F.SUBNODES(ANODE) NE 0
	IF S.NODES(F.SUBNODES(ANODE)) NE 0		'' subscript
		LET SUBNODE = F.SUBNODES(S.NODES(F.SUBNODES(ANODE)))
	ENDIF
ENDIF
LET DREF = DICTREF(VARTOKEN)
LET AUSE = FINDSPECUSE.F(DREF, .USE.LCL)
IF AUSE NE 0
	IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
		IF ISPUT NE 0
			WRITE AS "easg((char*)&"
		ENDIF
	ENDIF
	WRITE LEXEME(DREF) AS T *
	IF SUBNODE NE 0
		CALL GENARRSUBS(SUBNODE)
	ENDIF
	RETURN WITH USEMODE(AUSE)
ENDIF
	
LET AUSE = FINDSPECUSE.F(DREF, .USE.ATTR)
IF AUSE NE 0
	IF ISCOMMONATT(AUSE) NE 0 AND SUBNODE = 0
		CALL EASERR(1015, LEXEME(VARTOKEN))
		RETURN WITH USEMODE(AUSE)
	ENDIF
	IF ISPERSISTENT(USEOWNER(AUSE)) NE 0
		RETURN WITH GENPATTR(AUSE, VARTOKEN, SUBNODE, ISPUT)
	ELSE
		IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
			RETURN WITH GENPENTREF(AUSE, VARTOKEN, SUBNODE, ISPUT)
		ENDIF
	ENDIF
	LET AREF = FINDDICTENTRY.F(ETYPENAME(USEOWNER(AUSE)))
	IF SUBNODE NE 0 AND USESUBS(AUSE) EQ 0
		LET EMODE = GENEXP(SUBNODE)
		LET SUBNODE = 0
	ELSE							'' implicit subscript?
		IF FINDSPECUSE.F(AREF, .USE.LCL) EQ 0
			LET SUSE = FINDSPECUSE_F(AREF, .USE.ENT)
			IF SUSE NE 0
				LET SUSE = FINDSPECUSE.F(AREF, .USE.ATTR)
				WRITE ETYPENAME(USEOWNER(SUSE)) AS T *, "->"
			ENDIF
		ENDIF
		WRITE LEXEME(AREF) AS T *
	ENDIF
	WRITE LEXEME(DREF) AS "->", T *
	IF SUBNODE NE 0
		CALL GENARRSUBS(SUBNODE)
	ENDIF
	RETURN WITH USEMODE(AUSE)
ENDIF
LET AUSE = FINDSPECUSE.F(DREF, .USE.OATTR)
IF AUSE NE 0
	IF ISCOMMONATT(AUSE) NE 0 AND SUBNODE = 0
		CALL EASERR(1015, LEXEME(VARTOKEN))
		RETURN WITH USEMODE(AUSE)
	ENDIF
	LET ATT = USESETREFATT(AUSE)
	LET SDEF = SETATTRSETDEF(ATT)
	LET MREF = F.SETMMBRREFS(SDEF)
	LET AREF = FINDDICTENTRY.F(ETYPENAME(USEOWNER(AUSE)))
	LET SUSE = FINDSPECUSE.F(AREF, .USE.ENT)
	IF SUSE NE 0								'' owner entity is not 'SYSTEM'
		IF ISPERSISTENT(USEENTITY(SUSE)) NE 0	'' owner persistent?
			LET SAVP = 1
		ENDIF
	ENDIF
	IF USEMODE(AUSE) EQ .MODE.REF AND SAVP EQ 0
		WRITE AS "("
		CALL GENCAST(MMBRENT(MREF))
	ENDIF
	WRITE SUBSTR.F(LEXEME(DREF), 1, 2) AS T *
	IF ISPERSISTENT(ATTRTYPE(ATT)) NE 0			'' persistent set?
		WRITE AS "P"
	ELSE
		IF SAVP NE 0		'' owner persistent?
			WRITE AS "X"	'' but not set
		ENDIF
	ENDIF
	WRITE AS "EASSET_F("
	
	IF SAVP NE 0		'' owner persistent?
		WRITE AS "("
		CALL GENCAST(USEOWNER(AUSE))
		WRITE AS "fetch((iRef*)"
	ENDIF
	
	IF SUBNODE NE 0 AND USESUBS(AUSE) EQ 0
		LET MODE = GENEXP(SUBNODE)
		LET SUBNODE = 0
	ELSE								'' implicit subscript
		IF FINDSPECUSE.F(AREF, .USE.LCL) EQ 0
			IF SUSE EQ 0 AND ETYPEID(USEOWNER(AUSE)) NE 0
				CALL EASERR(1015, LEXEME(VARTOKEN))
			ENDIF
			LET SUSE = FINDSPECUSE.F(AREF, .USE.ATTR)	'' of 'system'
			IF SUSE EQ 0  AND ETYPEID(USEOWNER(AUSE)) NE 0
				CALL EASERR(1018, LEXEME(AREF))
			ELSE
				IF SUSE NE 0
					WRITE ETYPENAME(USEOWNER(SUSE)) AS T *, "->"
				ENDIF
			ENDIF
		ENDIF
		WRITE LEXEME(AREF) AS T *
	ENDIF
	IF SAVP NE 0
		WRITE AS "))"
	ENDIF
	
	WRITE ATTRNAME(USESETREFATT(AUSE)) AS "->", T *
	IF SUBNODE NE 0
		CALL GENARRSUBS(SUBNODE)
	ENDIF
	WRITE AS ")"
	IF USEMODE(AUSE) EQ .MODE.REF AND SAVP EQ 0
		WRITE AS ")"
	ENDIF
	RETURN WITH USEMODE(AUSE)
ENDIF
LET AUSE = FINDSPECUSE.F(DREF, .USE.MATTR)
IF AUSE NE 0
	IF ISCOMMONATT(AUSE) NE 0 AND SUBNODE = 0
		CALL EASERR(1015, LEXEME(VARTOKEN))
		RETURN WITH USEMODE(AUSE)
	ENDIF
	LET SDEF = USESETDEF(AUSE)
	LET MREF = F.SETMMBRREFS(SDEF)
	LET AREF = FINDDICTENTRY.F(ETYPENAME(MMBRENT(MREF)))
	LET SUSE = FINDSPECUSE.F(AREF, .USE.ENT)
	IF ISPERSISTENT(SDEF) NE 0
		LET SAVP = 1
	ENDIF
	
	IF USEMODE(AUSE) EQ .MODE.REF AND SAVP EQ 0
		WRITE AS "("
		CALL GENCAST(MMBRENT(MREF))
	ENDIF
	
	WRITE SUBSTR.F(LEXEME(DREF), 1, 2) AS T *
	IF SAVP NE 0
		WRITE AS "P"
	ELSE
		IF ISPERSISTENT(USEENTITY(SUSE)) NE 0
			WRITE AS "X"
		ENDIF
	ENDIF
	WRITE AS "EASSET_F("
	IF ISPERSISTENT(USEENTITY(SUSE)) NE 0
		WRITE AS "(iRef*)"
	ENDIF
		
	IF SUBNODE NE 0 AND USESUBS(AUSE) EQ 0
		LET MODE = GENEXP(SUBNODE)
		LET SUBNODE = 0
	ELSE				'' implicit subscript
		IF FINDSPECUSE.F(AREF, .USE.LCL) EQ 0
			IF SUSE EQ 0
				CALL EASERR(1015, LEXEME(VARTOKEN))
			ENDIF
			LET SUSE = FINDSPECUSE.F(AREF, .USE.ATTR)
			IF SUSE EQ 0
				CALL EASERR(1018, LEXEME(AREF))
			ELSE
				WRITE ETYPENAME(USEOWNER(SUSE)) AS T *, "->"
			ENDIF
		ENDIF
		WRITE LEXEME(AREF) AS T *	'' owning entity name
	ENDIF
	IF SUBNODE NE 0
		CALL GENARRSUBS(SUBNODE)
	ENDIF
	WRITE QUOTE_F(SETNAME(SDEF)) AS ", E_TXTLIT_F(_T(", T *, ")))"
	IF USEMODE(AUSE) EQ .MODE.REF AND SAVP EQ 0
		WRITE AS ")"
	ENDIF
	RETURN WITH USEMODE(AUSE)
ENDIF
LET AUSE = FINDSPECUSE.F(DREF, .USE.PROC)
IF AUSE NE 0
	CALL GENFUNC(F.SUBNODES(ANODE))	'' function
	LET MODE = USEMODE(AUSE)
ELSE
	LET AUSE = FINDPREFUSE.F(VARTOKEN, 1)
	WRITE LEXEME(VARTOKEN) AS T *
ENDIF
RETURN WITH MODE
END
Function ARRTYPE_F T ETYPE STARS TXT
IF TARGETNAME(ETYPE) NE 0
	LET TXT = TARGETNAME(ETYPE)
ELSE
	LET TXT = CONCAT.F(ETYPENAME(ETYPE), "*")
ENDIF
LET TXT = CONCAT.F("(", TXT)
WHILE STARS GT 0
DO
	LET TXT = CONCAT.F(TXT, "*")
	LET STARS = STARS - 1
LOOP
LET TXT = CONCAT.F(TXT, ")")
RETURN WITH TXT
END
Routine GENRESERVE ANODE ARRMODE AUSE SUBNODE I MODE ETYPE
LET AUSE = FINDPREFUSE.F(START(ANODE), 1)
LET I = USESUBS(AUSE)
IF I EQ 0
	CALL EASERR(1003, LEXEME(START(ANODE)))
	RETURN
ENDIF
LET ETYPE = USEENTITY(AUSE)
LET ARRMODE = GENVAR(ANODE, 1)
WRITE AS " = "
LET I = USESUBS(AUSE)
LET SUBNODE = S.NODES(F.SUBNODES(ANODE))
IF SUBNODE NE 0
	IF MATCHNUM(F.SUBNODES(SUBNODE)) = 1	'' an expression, not 'star'
		LET I = I - 1			'' ..this is not last dimension
	ENDIF
ENDIF
WRITE ARRTYPE.F(ETYPE, I) AS T *
WRITE AS "calloc("
LET MODE = GENEXP(S.NODES(ANODE))
LET I = I - 1
WRITE ARRTYPE.F(ETYPE, I) AS " + 1, sizeof", T *, ");", /
WRITE AS B 8
LET MODE = GENVAR(ANODE, 1)
WRITE AS "[0] = "
WRITE ARRTYPE.F(ETYPE, I) AS T *, "("
LET MODE = GENEXP(S.NODES(ANODE))
WRITE AS ");", /
RETURN END
Routine GENCALL ANODE SUBNODE EMODE AUSE FIRST YLD
WRITE LEXEME(DICTREF(START(ANODE))) AS T *, "("
LET	FIRST = 1
LET ANODE = S.NODES(ANODE)		'' arguments?
WHILE ANODE NE 0
DO
	LET SUBNODE = F.SUBNODES(ANODE)
	IF SCRIPTCODE(SUBNODE) NE 0
		LET YLD = 1
	ENDIF
	WHILE SUBNODE NE 0
	DO
		IF FIRST EQ 0
			WRITE AS ", "
		ELSE
			LET FIRST = 0
		ENDIF
		IF YLD EQ 0
			LET EMODE = GENEXP(F.SUBNODES(SUBNODE))
		ELSE
			LET EMODE = GENVAR(F.SUBNODES(SUBNODE), 1)
		ENDIF
		LET SUBNODE = S.NODES(SUBNODE)
	LOOP
	LET ANODE = S.NODES(ANODE)
LOOP
WRITE AS ")"
RETURN END
Routine GENFUNC ANODE EMODE AUSE FIRST
WRITE LEXEME(DICTREF(START(ANODE))) AS T *, "("
IF S.NODES(ANODE) NE 0
	FIRST = 1
	ANODE = F.SUBNODES(S.NODES(ANODE))
	WHILE ANODE NE 0
	DO
		IF FIRST EQ 0
			WRITE AS ", "
		ENDIF
		LET EMODE = GENEXP(ANODE)
		LET FIRST = 0
		ANODE = S.NODES(ANODE)
	LOOP
ENDIF
WRITE AS ")"
RETURN END
Routine GENSTMT APROC ASTMT ETYPE RNAME ANODE VARNODE EXPNODE SUBNODE AUSE AUSE2 MODE EMODE COUNT
LET CURRLINE = STMTLINE(ASTMT)		'' for error location
LET RNAME = RULENAME(STMTRULE(ASTMT))
LET ANODE = F.PARSENODES(ASTMT)		'' most need this...
WRITE AS B 8
IF RNAME = "CREATE"
	LET AUSE = FINDSPECUSE.F(DICTREF(START(ANODE)), .USE.ENT)
	IF AUSE EQ 0
		CALL EASERR(1011, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	LET ISUSEDTYPE(USEENTITY(AUSE)) = 1
	IF S.NODES(ANODE) NE 0		'' called ?
		LET ANODE = S.NODES(ANODE)
	ENDIF
	LET MODE = GENVAR(ANODE, 1)
	IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
		WRITE ETYPENAME(USEENTITY(AUSE)) AS ", c_", T *, "());"
		LET USEPERSIST = 1
	ELSE
		WRITE ETYPENAME(USEENTITY(AUSE)) AS "= c_", T *, "();"
	ENDIF
	WRITE AS /
	RETURN
ENDIF
IF RNAME = "DESTROY"
	LET AUSE = FINDSPECUSE.F(DICTREF(START(ANODE)), .USE.ENT)
	IF AUSE EQ 0
		CALL EASERR(1011, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	IF S.NODES(ANODE) NE 0		'' called ?
		LET ANODE = S.NODES(ANODE)
	ENDIF
	WRITE CONCAT.F("d_", ETYPENAME(USEENTITY(AUSE))) AS T *, "("
	LET MODE = GENVAR(ANODE, 0)
	WRITE AS ");", /
	RETURN
ENDIF
IF RNAME = "ASSIGN"
	LET VARNODE = ANODE
	LET EXPNODE = S.NODES(VARNODE)
	LET AUSE = FINDPREFUSE_F(START(VARNODE), 1)
	IF USEMODE(AUSE) EQ .MODE.TXT
		WRITE AS "E_TXTASG_R(&"
		LET MODE = GENVAR(VARNODE, 0)
		WRITE AS ", "
		LET MODE = GENEXP(EXPNODE)
		WRITE AS ");", /
		RETURN
	ENDIF
	IF USETYPE(AUSE) EQ .USE.PROC		'' left routine invocation
		LET ANODE = F.SUBNODES(VARNODE)
		WRITE LEXEME(DICTREF(START(ANODE))) AS "Q", T *, "("
		LET ANODE = F.SUBNODES(S.NODES(ANODE))
		WHILE ANODE NE 0
		DO
			LET MODE = GENEXP(ANODE)
			WRITE AS ", "
			LET ANODE = S.NODES(ANODE)
		LOOP
		LET MODE = GENEXP(EXPNODE)
		WRITE AS ");", /
		RETURN
	ENDIF
	
	IF USETYPE(AUSE) EQ .USE.OATTR
	 OR USETYPE(AUSE) EQ .USE.MATTR
		CALL EASERR(1017, LEXEME(START(ANODE)))		'' can't assign to synthesized attribute
		RETURN
	ENDIF 
	IF ISPERSISTENT(USEENTITY(AUSE)) NE 0
		LET MODE = GENVAR(VARNODE, 1)
		WRITE AS ", (iRef*)"
		LET MODE = GENEXP(EXPNODE)
		WRITE AS ");", /
		RETURN
	ENDIF
	LET MODE = GENVAR(VARNODE, 1)
	WRITE AS " = "
	IF USESUBS(AUSE) NE 0
		LET COUNT = 0
		LET ANODE = S.NODES(F.SUBNODES(VARNODE))
		IF ANODE NE 0		'' subscripted
			LET ANODE = F.SUBNODES(ANODE)
			WHILE ANODE NE 0
			DO
				IF MATCHNUM(ANODE) EQ 1	'' not '*'
					LET COUNT = COUNT + 1
				ENDIF
				LET ANODE = S.NODES(ANODE)
			LOOP
			LET COUNT = USESUBS(AUSE) - COUNT
		ENDIF
	ENDIF
	IF MODE = .MODE.REF OR USESUBS(AUSE) NE 0
		WRITE AS "("
		''IF MODE EQ .MODE.REF AND USETYPE(AUSE) EQ .USE.LCL
		''	WRITE AS "struct "
		''ENDIF
		WRITE MAKETYPE.F(USEENTITY(AUSE), COUNT) AS T *, ")"
	ENDIF
	LET EMODE = GENEXP(EXPNODE)
	WRITE AS ";", /
	RETURN
ENDIF
IF RNAME = "CALL"
	AUSE = FINDSPECUSE.F(DICTREF(START(ANODE)), .USE.PROC)
	IF AUSE EQ 0
		CALL EASERR(1012, LEXEME(START(ANODE)))
		RETURN
	ENDIF
	CALL GENCALL(F.PARSENODES(ASTMT))
	WRITE AS ";", /
	RETURN
ENDIF
IF RNAME = "GOTO"
	WRITE LEXEME(DICTREF(START(ANODE))) AS "goto ", T *, ";", /
	RETURN
ENDIF
IF RNAME = "LBL"
	WRITE LEXEME(DICTREF(S.TOKENLIST(START(ANODE)))) AS B 1, T *, ":", /
	'' some use_lbl stuff here... and maybe a null stmt?
	LET ASTMT = S.STMTS(ASTMT)
	IF ASTMT NE 0
		IF RULENAME(STMTRULE(ASTMT)) EQ "ENDIF" 
		 OR RULENAME(STMTRULE(ASTMT)) = "ELSE"
			WRITE AS ";"
		ENDIF
	ENDIF
	RETURN
ENDIF
IF RNAME = "IF"
	IF MATCHNUM(ANODE) EQ 2
		RETURN			'' a IS A form - see scripting
	ENDIF
	WRITE AS "if ("
	CALL GENLOGICL(ANODE)
	WRITE AS ") {", /
	RETURN
ENDIF
IF RNAME = "ELSE"
	'' some checking here !!!
	WRITE AS "}", /, B 8, "else {", /
	RETURN
ENDIF
IF RNAME = "ENDIF"
	'' some checking here !!!
	WRITE AS "}", /
	RETURN
ENDIF
IF RNAME = "RET"
	LET GORETLBL = 1			'' we will need 'retlbl'
	LET ANODE = S.NODES(ANODE)
	IF ANODE NE 0				'' return has 'with' value
		IF RETURNATT(APROC) EQ 0
			CALL EASERR(-1013, 0)
		ENDIF
		LET ANODE = F.SUBNODES(ANODE)
		IF ETYPENAME(ATTRTYPE(RETURNATT(APROC))) = "Text"
			WRITE AS "E_TXTASG_R(&rval, "
			LET MODE = GENEXP(ANODE)
			WRITE AS ");", /
		ELSE
			WRITE MAKEATTRTYPE.F(RETURNATT(APROC)) AS "rval = (", T *, ")"
			LET MODE = GENEXP(ANODE)
			WRITE AS ";", /
		ENDIF
	ELSE
		IF RETURNATT(APROC) NE 0
			CALL EASERR(-1014, 0)
		ENDIF
	ENDIF
	WRITE AS "goto retlbl;", /
	RETURN
ENDIF
IF RNAME = "RESERVE"
	IF S.NODES(S.NODES(ANODE)) NE 0		'' a 'by' expression - done in scripting
		RETURN
	ENDIF
	CALL GENRESERVE(ANODE)
ENDIF
RETURN END
Routine GENSIZES ASCHEMA TXT ETYPE
'' generate size constants for entity types
LET ETYPE = F.ETYPES(ASCHEMA)
WHILE ETYPE NE 0
DO
	IF ISPROC(ETYPE) = 0
		LET TXT = CONCAT.F("int Z_", ETYPENAME(ETYPE))
		WRITE TXT, ETYPENAME(ETYPE) AS T *, " = sizeof(", T *, ");", /
	ENDIF
	IF ISPERSISTENT(ETYPE) NE 0
		CALL GENMAP(ETYPE)
	ENDIF
	LET ETYPE = S.ETYPES(ETYPE)
LOOP
WRITE AS /
RETURN END
Routine GENMAP ETYPE N I ATTR
LET ATTR = F.ATTRDEFS(ETYPE)
WHILE ATTR NE 0
DO
	LET N = N + 1
	LET ATTR = S.ATTRDEFS(ATTR)
LOOP
LET ATTR = F.ATTRDEFS(ETYPE)
IF NOHDR(SCHEMAREF(ETYPE)) EQ 0
	LET N = N + 4		'' schema uses explicit header attributes (sets)
ELSE
	FOR I = 1 TO 4
	DO
		LET ATTR = S.ATTRDEFS(ATTR)	'' skip standard hdr attrs
	LOOP
ENDIF
WRITE ETYPENAME(ETYPE), N + 2, ETYPENAME(ETYPE), N AS
	"const int Y_", T *, "[", I 3, "] = { sizeof(", T *, "), ", I 3, ", 1, 1, 4, 5"
WHILE ATTR NE 0
DO
	LET ETYPE = ATTRTYPE(ATTR)
	LET N = .MODE.REF		'' tentative
	FOR I = 1 TO 3
	DO
		IF ETYPE = E_BUILTINS(I)
			LET N = I
			LEAVE
		ENDIF
	LOOP
	IF N = .MODE.REF
		IF ISPERSISTENT(ETYPE) NE 0
			LET N = 5
		ENDIF
	ENDIF
	WRITE N AS ", ", I 2 
	LET ATTR = S.ATTRDEFS(ATTR)
LOOP
WRITE AS " };", /
RETURN END
Routine GENPROCINCL ASCHEMA SYSNAME STYPENAME SREF ID TXT
'' generate procedure includes
PRINT 1 LINE THUS
#include \"stdafx.h\"
PRINT 1 LINE THUS
#include \"malloc.h\"
IF USEPERSIST NE 0
	PRINT 1 LINE THUS
	#define EASpersist
ENDIF
PRINT 1 LINE THUS
#include \"libopts.h\"
PRINT 1 LINE THUS
#include \"math.h\"
LET TXT = CONCAT.F(GENNAME(ASCHEMA), ".h")
WRITE QUOTE.F(TXT) AS "#include ", T *, /, /
CALL GENADDTYPES(ASCHEMA)
LET SYSNAME = GENNAME(ASCHEMA)
IF THESYSTEM(ASCHEMA) != 0
	LET STYPENAME = CONCAT.F(SYSNAME, "_sys")
	LET SREF = CONCAT.F(STYPENAME, "*")
	WRITE SREF, SYSNAME  AS T *, S 1, T *, ";", /
ENDIF
WRITE SYSNAME AS /, "void ", T *, "_init() {", /
IF THESYSTEM(ASCHEMA) != 0
	LET ID = SCHEMAID(ASCHEMA)
	WRITE SYSNAME, " = (", SREF, ")E_CREATE_F( 0,", ID, ", sizeof(", STYPENAME, "));"    
		AS T *, T *, T *, T *, I 4, T *, T *, T *, /
	WRITE CONCAT.F(SYSNAME, "_sets();") AS T *, /
ENDIF
WRITE SYSNAME AS T *,"_addTypes();", /
WRITE "}" AS T *, /
RETURN END
Routine GENINIT SYSETYPE SYSNAME STYPENAME SREF ID ATT
WRITE AS /, "void easinit() {", /
LET SYSETYPE = F.SYSTEMS
WHILE SYSETYPE NE 0
DO
	LET SYSNAME = GENNAME(SCHEMAREF(SYSETYPE))
	WRITE SYSNAME AS T *, "_init();", /
	SYSETYPE = S.ETYPES(SYSETYPE)
LOOP
WRITE "}" AS T *, /
RETURN END
Routine GENADDTYPES ASCHEMA ETYPE
WRITE GENNAME(ASCHEMA) AS "void ", T *, "_addTypes() {", /
LET ETYPE = F.ETYPES(ASCHEMA)
WHILE ETYPE NE 0
DO
	IF ISPROC(ETYPE) EQ 0
		WRITE ETYPENAME(ETYPE) AS
				"#ifdef _", T *, /
		WRITE QUOTE.F(ETYPENAME(ETYPE)), SCHEMAID(ASCHEMA), ETYPEID(ETYPE) AS
			"addEType(E_TXTLIT_F(_T(", T *, ")), ", I 4, ", ", I 4, ", "
		IF ISPERSISTENT(ETYPE) NE 0
			WRITE CONCAT.F("Y_", ETYPENAME(ETYPE)) AS T *
		ELSE
			WRITE AS "0"
		ENDIF
		WRITE AS ");", /, "#endif", /
	ENDIF
	LET ETYPE = S.ETYPES(ETYPE)
LOOP
WRITE AS "}", /
RETURN END
Routine GENPROC APROC AUSE ETYPE ASTMT AREF ATT FIRST
LET GORETLBL = 0		'' catch 'RETURN' stmts
LET AUSE = FINDSPECUSE.F(PDICTREF(APROC), .USE.PROC)
IF RETURNATT(APROC) EQ 0
	WRITE AS "void "
ELSE
	WRITE MAKEATTRTYPE.F(RETURNATT(APROC)) AS T *, S 1
ENDIF
LET ETYPE = USEENTITY(AUSE)
IF ETYPENAME(ETYPE) EQ "MAIN"
	WRITE AS "main"
ELSE
	WRITE ETYPENAME(ETYPE) AS T *
ENDIF
CALL GENARGLIST(ETYPE)
WRITE AS " {", /
LET ATT = F.ATTRDEFS(ETYPE)		'' generate local var declarations
WHILE ATT NE 0
DO
	IF ISPARAM(ATT) EQ 0 AND ATT NE RETURNATT(APROC)
		WRITE MAKEATTRTYPE.F(ATT) AS T *		
		WRITE ATTRNAME(ATT) AS S 1, T *, "= 0;", /
	ENDIF
	LET ATT = S.ATTRDEFS(ATT)
LOOP
IF RETURNATT(APROC) NE 0 
	WRITE MAKEATTRTYPE.F(RETURNATT(APROC)), "rval" AS T *, S 1, T *, " = 0;", /
ENDIF
LET ATT = F.ATTRDEFS(ETYPE)
WHILE ATT NE 0
DO
	IF ISPARAM(ATT) NE 0
		IF ETYPENAME(ATTRTYPE(ATT)) = "Text"
			WRITE ATTRNAME(ATT) AS "E_TXTINC_R(", T *, ");", /
		ENDIF
	ENDIF
	LET ATT = S.ATTRDEFS(ATT)
LOOP
IF ETYPENAME(ETYPE) = "MAIN"
	WRITE AS B 8, "easinit();", /
ENDIF
LET ASTMT = F.STMTS(APROC)
WHILE ASTMT NE 0
DO
	CALL GENSTMT(APROC, ASTMT)
	LET ASTMT = S.STMTS(ASTMT)
LOOP
IF GORETLBL NE 0
	WRITE AS B 1, "retlbl:", /
ENDIF
LET ATT = F.ATTRDEFS(ETYPE)
WHILE ATT NE 0				'' clean up Text mode locals/args
DO
	LET AREF = FINDDICTENTRY_F(ATTRNAME(ATT))
	LET AUSE = FINDSPECUSE_F(AREF, .USE.LCL)
	IF ATT NE RETURNATT(APROC)
		IF ETYPENAME(ATTRTYPE(ATT)) = "Text" 
			WRITE ATTRNAME(ATT) AS "E_TXTDEL_R(", T *, ");", /
		ENDIF
		IF USEMODE(AUSE) = .MODE.REF AND ISPERSISTENT(ATTRTYPE(ATT)) NE 0 
			WRITE ATTRNAME(ATT) AS "eunasg((char*)&", T *, ");", /
		ENDIF
	ENDIF
	CALL DESTROYUSE(AUSE)
	LET ATT = S.ATTRDEFS(ATT)
LOOP
'' delete lbls, goto per/case etc - someday***********************************
WRITE AS B 8, "return"
IF RETURNATT(APROC) NE 0
	WRITE AS " rval"
ENDIF
WRITE AS ";", /, "}", /
RETURN END
Routine GENARGLIST ETYPE FIRST ATT
LET FIRST = 1
WRITE AS "("
LET ATT = F.ATTRDEFS(ETYPE)
WHILE ATT NE 0
DO
	IF ISPARAM(ATT) NE 0
		IF FIRST EQ 0
			WRITE AS ", "
		ENDIF
		FIRST = 0
		WRITE MAKEATTRTYPE_F(ATT) AS T *
		IF ISYIELD(ATT) NE 0
			WRITE AS "&"
		ENDIF
		WRITE ATTRNAME(ATT) AS S 1, T *
	ENDIF
	LET ATT = S.ATTRDEFS(ATT)
LOOP
WRITE AS ")"
RETURN END
Function MAKEATTRTYPE_F T ATT TXT ETYPE STARS
LET ETYPE = ATTRTYPE(ATT)
LET STARS = SUBSCRIPTS(ATT)
LET TXT = MAKETYPE_F(ETYPE, STARS)
RETURN WITH TXT
END
Function MAKETYPE_F T ETYPE STARS TXT
IF TARGETNAME(ETYPE) NE 0
	LET TXT = TARGETNAME(ETYPE)
ELSE
	LET TXT = CONCAT.F("struct ", ETYPENAME(ETYPE))
	LET TXT = CONCAT.F(TXT, "*")
ENDIF
WHILE STARS GT 0
DO
	LET TXT = CONCAT.F(TXT, "*")
	LET STARS = STARS - 1
LOOP
RETURN WITH TXT
END
